{"version":3,"file":"@motionone-BkHL0rzb.js","sources":["../../node_modules/@motionone/utils/dist/array.es.js","../../node_modules/@motionone/utils/dist/clamp.es.js","../../node_modules/@motionone/utils/dist/defaults.es.js","../../node_modules/@motionone/utils/dist/is-number.es.js","../../node_modules/@motionone/utils/dist/is-easing-list.es.js","../../node_modules/@motionone/utils/dist/wrap.es.js","../../node_modules/@motionone/utils/dist/easing.es.js","../../node_modules/@motionone/utils/dist/mix.es.js","../../node_modules/@motionone/utils/dist/noop.es.js","../../node_modules/@motionone/utils/dist/progress.es.js","../../node_modules/@motionone/utils/dist/offset.es.js","../../node_modules/@motionone/utils/dist/interpolate.es.js","../../node_modules/@motionone/utils/dist/is-cubic-bezier.es.js","../../node_modules/@motionone/utils/dist/is-easing-generator.es.js","../../node_modules/@motionone/utils/dist/is-function.es.js","../../node_modules/@motionone/utils/dist/is-string.es.js","../../node_modules/@motionone/utils/dist/time.es.js","../../node_modules/@motionone/easing/dist/cubic-bezier.es.js","../../node_modules/@motionone/easing/dist/steps.es.js","../../node_modules/@motionone/animation/dist/utils/easing.es.js","../../node_modules/@motionone/animation/dist/Animation.es.js","../../node_modules/@motionone/types/dist/MotionValue.es.js","../../node_modules/@motionone/dom/dist/animate/data.es.js","../../node_modules/@motionone/dom/dist/animate/utils/transforms.es.js","../../node_modules/@motionone/dom/dist/animate/utils/css-var.es.js","../../node_modules/@motionone/dom/dist/animate/utils/feature-detection.es.js","../../node_modules/@motionone/dom/dist/animate/utils/easing.es.js","../../node_modules/@motionone/dom/dist/animate/utils/keyframes.es.js","../../node_modules/@motionone/dom/dist/animate/utils/get-style-name.es.js","../../node_modules/@motionone/dom/dist/animate/style.es.js","../../node_modules/@motionone/dom/dist/animate/utils/stop-animation.es.js","../../node_modules/@motionone/dom/dist/animate/utils/get-unit.es.js","../../node_modules/@motionone/dom/dist/animate/animate-style.es.js","../../node_modules/@motionone/dom/dist/animate/utils/options.es.js","../../node_modules/@motionone/dom/dist/utils/resolve-elements.es.js","../../node_modules/@motionone/dom/dist/animate/utils/controls.es.js","../../node_modules/@motionone/dom/dist/utils/stagger.es.js","../../node_modules/@motionone/dom/dist/animate/create-animate.es.js","../../node_modules/@motionone/dom/dist/animate/index.es.js"],"sourcesContent":["function addUniqueItem(array, item) {\n    array.indexOf(item) === -1 && array.push(item);\n}\nfunction removeItem(arr, item) {\n    const index = arr.indexOf(item);\n    index > -1 && arr.splice(index, 1);\n}\n\nexport { addUniqueItem, removeItem };\n","const clamp = (min, max, v) => Math.min(Math.max(v, min), max);\n\nexport { clamp };\n","const defaults = {\n    duration: 0.3,\n    delay: 0,\n    endDelay: 0,\n    repeat: 0,\n    easing: \"ease\",\n};\n\nexport { defaults };\n","const isNumber = (value) => typeof value === \"number\";\n\nexport { isNumber };\n","import { isNumber } from './is-number.es.js';\n\nconst isEasingList = (easing) => Array.isArray(easing) && !isNumber(easing[0]);\n\nexport { isEasingList };\n","const wrap = (min, max, v) => {\n    const rangeSize = max - min;\n    return ((((v - min) % rangeSize) + rangeSize) % rangeSize) + min;\n};\n\nexport { wrap };\n","import { isEasingList } from './is-easing-list.es.js';\nimport { wrap } from './wrap.es.js';\n\nfunction getEasingForSegment(easing, i) {\n    return isEasingList(easing)\n        ? easing[wrap(0, easing.length, i)]\n        : easing;\n}\n\nexport { getEasingForSegment };\n","const mix = (min, max, progress) => -progress * min + progress * max + min;\n\nexport { mix };\n","const noop = () => { };\nconst noopReturn = (v) => v;\n\nexport { noop, noopReturn };\n","const progress = (min, max, value) => max - min === 0 ? 1 : (value - min) / (max - min);\n\nexport { progress };\n","import { mix } from './mix.es.js';\nimport { progress } from './progress.es.js';\n\nfunction fillOffset(offset, remaining) {\n    const min = offset[offset.length - 1];\n    for (let i = 1; i <= remaining; i++) {\n        const offsetProgress = progress(0, remaining, i);\n        offset.push(mix(min, 1, offsetProgress));\n    }\n}\nfunction defaultOffset(length) {\n    const offset = [0];\n    fillOffset(offset, length - 1);\n    return offset;\n}\n\nexport { defaultOffset, fillOffset };\n","import { mix } from './mix.es.js';\nimport { noopReturn } from './noop.es.js';\nimport { fillOffset, defaultOffset } from './offset.es.js';\nimport { progress } from './progress.es.js';\nimport { getEasingForSegment } from './easing.es.js';\nimport { clamp } from './clamp.es.js';\n\nfunction interpolate(output, input = defaultOffset(output.length), easing = noopReturn) {\n    const length = output.length;\n    /**\n     * If the input length is lower than the output we\n     * fill the input to match. This currently assumes the input\n     * is an animation progress value so is a good candidate for\n     * moving outside the function.\n     */\n    const remainder = length - input.length;\n    remainder > 0 && fillOffset(input, remainder);\n    return (t) => {\n        let i = 0;\n        for (; i < length - 2; i++) {\n            if (t < input[i + 1])\n                break;\n        }\n        let progressInRange = clamp(0, 1, progress(input[i], input[i + 1], t));\n        const segmentEasing = getEasingForSegment(easing, i);\n        progressInRange = segmentEasing(progressInRange);\n        return mix(output[i], output[i + 1], progressInRange);\n    };\n}\n\nexport { interpolate };\n","import { isNumber } from './is-number.es.js';\n\nconst isCubicBezier = (easing) => Array.isArray(easing) && isNumber(easing[0]);\n\nexport { isCubicBezier };\n","const isEasingGenerator = (easing) => typeof easing === \"object\" &&\n    Boolean(easing.createAnimation);\n\nexport { isEasingGenerator };\n","const isFunction = (value) => typeof value === \"function\";\n\nexport { isFunction };\n","const isString = (value) => typeof value === \"string\";\n\nexport { isString };\n","const time = {\n    ms: (seconds) => seconds * 1000,\n    s: (milliseconds) => milliseconds / 1000,\n};\n\nexport { time };\n","import { noopReturn } from '@motionone/utils';\n\n/*\n  Bezier function generator\n\n  This has been modified from GaÃ«tan Renaudeau's BezierEasing\n  https://github.com/gre/bezier-easing/blob/master/src/index.js\n  https://github.com/gre/bezier-easing/blob/master/LICENSE\n  \n  I've removed the newtonRaphsonIterate algo because in benchmarking it\n  wasn't noticiably faster than binarySubdivision, indeed removing it\n  usually improved times, depending on the curve.\n\n  I also removed the lookup table, as for the added bundle size and loop we're\n  only cutting ~4 or so subdivision iterations. I bumped the max iterations up\n  to 12 to compensate and this still tended to be faster for no perceivable\n  loss in accuracy.\n\n  Usage\n    const easeOut = cubicBezier(.17,.67,.83,.67);\n    const x = easeOut(0.5); // returns 0.627...\n*/\n// Returns x(t) given t, x1, and x2, or y(t) given t, y1, and y2.\nconst calcBezier = (t, a1, a2) => (((1.0 - 3.0 * a2 + 3.0 * a1) * t + (3.0 * a2 - 6.0 * a1)) * t + 3.0 * a1) * t;\nconst subdivisionPrecision = 0.0000001;\nconst subdivisionMaxIterations = 12;\nfunction binarySubdivide(x, lowerBound, upperBound, mX1, mX2) {\n    let currentX;\n    let currentT;\n    let i = 0;\n    do {\n        currentT = lowerBound + (upperBound - lowerBound) / 2.0;\n        currentX = calcBezier(currentT, mX1, mX2) - x;\n        if (currentX > 0.0) {\n            upperBound = currentT;\n        }\n        else {\n            lowerBound = currentT;\n        }\n    } while (Math.abs(currentX) > subdivisionPrecision &&\n        ++i < subdivisionMaxIterations);\n    return currentT;\n}\nfunction cubicBezier(mX1, mY1, mX2, mY2) {\n    // If this is a linear gradient, return linear easing\n    if (mX1 === mY1 && mX2 === mY2)\n        return noopReturn;\n    const getTForX = (aX) => binarySubdivide(aX, 0, 1, mX1, mX2);\n    // If animation is at start/end, return t without easing\n    return (t) => t === 0 || t === 1 ? t : calcBezier(getTForX(t), mY1, mY2);\n}\n\nexport { cubicBezier };\n","import { clamp } from '@motionone/utils';\n\nconst steps = (steps, direction = \"end\") => (progress) => {\n    progress =\n        direction === \"end\"\n            ? Math.min(progress, 0.999)\n            : Math.max(progress, 0.001);\n    const expanded = progress * steps;\n    const rounded = direction === \"end\" ? Math.floor(expanded) : Math.ceil(expanded);\n    return clamp(0, 1, rounded / steps);\n};\n\nexport { steps };\n","import { cubicBezier, steps } from '@motionone/easing';\nimport { isFunction, isCubicBezier, noopReturn } from '@motionone/utils';\n\nconst namedEasings = {\n    ease: cubicBezier(0.25, 0.1, 0.25, 1.0),\n    \"ease-in\": cubicBezier(0.42, 0.0, 1.0, 1.0),\n    \"ease-in-out\": cubicBezier(0.42, 0.0, 0.58, 1.0),\n    \"ease-out\": cubicBezier(0.0, 0.0, 0.58, 1.0),\n};\nconst functionArgsRegex = /\\((.*?)\\)/;\nfunction getEasingFunction(definition) {\n    // If already an easing function, return\n    if (isFunction(definition))\n        return definition;\n    // If an easing curve definition, return bezier function\n    if (isCubicBezier(definition))\n        return cubicBezier(...definition);\n    // If we have a predefined easing function, return\n    if (namedEasings[definition])\n        return namedEasings[definition];\n    // If this is a steps function, attempt to create easing curve\n    if (definition.startsWith(\"steps\")) {\n        const args = functionArgsRegex.exec(definition);\n        if (args) {\n            const argsArray = args[1].split(\",\");\n            return steps(parseFloat(argsArray[0]), argsArray[1].trim());\n        }\n    }\n    return noopReturn;\n}\n\nexport { getEasingFunction };\n","import { noopReturn, defaults, isEasingGenerator, isEasingList, interpolate } from '@motionone/utils';\nimport { getEasingFunction } from './utils/easing.es.js';\n\nclass Animation {\n    constructor(output, keyframes = [0, 1], { easing, duration: initialDuration = defaults.duration, delay = defaults.delay, endDelay = defaults.endDelay, repeat = defaults.repeat, offset, direction = \"normal\", autoplay = true, } = {}) {\n        this.startTime = null;\n        this.rate = 1;\n        this.t = 0;\n        this.cancelTimestamp = null;\n        this.easing = noopReturn;\n        this.duration = 0;\n        this.totalDuration = 0;\n        this.repeat = 0;\n        this.playState = \"idle\";\n        this.finished = new Promise((resolve, reject) => {\n            this.resolve = resolve;\n            this.reject = reject;\n        });\n        easing = easing || defaults.easing;\n        if (isEasingGenerator(easing)) {\n            const custom = easing.createAnimation(keyframes);\n            easing = custom.easing;\n            keyframes = custom.keyframes || keyframes;\n            initialDuration = custom.duration || initialDuration;\n        }\n        this.repeat = repeat;\n        this.easing = isEasingList(easing) ? noopReturn : getEasingFunction(easing);\n        this.updateDuration(initialDuration);\n        const interpolate$1 = interpolate(keyframes, offset, isEasingList(easing) ? easing.map(getEasingFunction) : noopReturn);\n        this.tick = (timestamp) => {\n            var _a;\n            // TODO: Temporary fix for OptionsResolver typing\n            delay = delay;\n            let t = 0;\n            if (this.pauseTime !== undefined) {\n                t = this.pauseTime;\n            }\n            else {\n                t = (timestamp - this.startTime) * this.rate;\n            }\n            this.t = t;\n            // Convert to seconds\n            t /= 1000;\n            // Rebase on delay\n            t = Math.max(t - delay, 0);\n            /**\n             * If this animation has finished, set the current time\n             * to the total duration.\n             */\n            if (this.playState === \"finished\" && this.pauseTime === undefined) {\n                t = this.totalDuration;\n            }\n            /**\n             * Get the current progress (0-1) of the animation. If t is >\n             * than duration we'll get values like 2.5 (midway through the\n             * third iteration)\n             */\n            const progress = t / this.duration;\n            // TODO progress += iterationStart\n            /**\n             * Get the current iteration (0 indexed). For instance the floor of\n             * 2.5 is 2.\n             */\n            let currentIteration = Math.floor(progress);\n            /**\n             * Get the current progress of the iteration by taking the remainder\n             * so 2.5 is 0.5 through iteration 2\n             */\n            let iterationProgress = progress % 1.0;\n            if (!iterationProgress && progress >= 1) {\n                iterationProgress = 1;\n            }\n            /**\n             * If iteration progress is 1 we count that as the end\n             * of the previous iteration.\n             */\n            iterationProgress === 1 && currentIteration--;\n            /**\n             * Reverse progress if we're not running in \"normal\" direction\n             */\n            const iterationIsOdd = currentIteration % 2;\n            if (direction === \"reverse\" ||\n                (direction === \"alternate\" && iterationIsOdd) ||\n                (direction === \"alternate-reverse\" && !iterationIsOdd)) {\n                iterationProgress = 1 - iterationProgress;\n            }\n            const p = t >= this.totalDuration ? 1 : Math.min(iterationProgress, 1);\n            const latest = interpolate$1(this.easing(p));\n            output(latest);\n            const isAnimationFinished = this.pauseTime === undefined &&\n                (this.playState === \"finished\" || t >= this.totalDuration + endDelay);\n            if (isAnimationFinished) {\n                this.playState = \"finished\";\n                (_a = this.resolve) === null || _a === void 0 ? void 0 : _a.call(this, latest);\n            }\n            else if (this.playState !== \"idle\") {\n                this.frameRequestId = requestAnimationFrame(this.tick);\n            }\n        };\n        if (autoplay)\n            this.play();\n    }\n    play() {\n        const now = performance.now();\n        this.playState = \"running\";\n        if (this.pauseTime !== undefined) {\n            this.startTime = now - this.pauseTime;\n        }\n        else if (!this.startTime) {\n            this.startTime = now;\n        }\n        this.cancelTimestamp = this.startTime;\n        this.pauseTime = undefined;\n        this.frameRequestId = requestAnimationFrame(this.tick);\n    }\n    pause() {\n        this.playState = \"paused\";\n        this.pauseTime = this.t;\n    }\n    finish() {\n        this.playState = \"finished\";\n        this.tick(0);\n    }\n    stop() {\n        var _a;\n        this.playState = \"idle\";\n        if (this.frameRequestId !== undefined) {\n            cancelAnimationFrame(this.frameRequestId);\n        }\n        (_a = this.reject) === null || _a === void 0 ? void 0 : _a.call(this, false);\n    }\n    cancel() {\n        this.stop();\n        this.tick(this.cancelTimestamp);\n    }\n    reverse() {\n        this.rate *= -1;\n    }\n    commitStyles() { }\n    updateDuration(duration) {\n        this.duration = duration;\n        this.totalDuration = duration * (this.repeat + 1);\n    }\n    get currentTime() {\n        return this.t;\n    }\n    set currentTime(t) {\n        if (this.pauseTime !== undefined || this.rate === 0) {\n            this.pauseTime = t;\n        }\n        else {\n            this.startTime = performance.now() - t / this.rate;\n        }\n    }\n    get playbackRate() {\n        return this.rate;\n    }\n    set playbackRate(rate) {\n        this.rate = rate;\n    }\n}\n\nexport { Animation };\n","/**\n * The MotionValue tracks the state of a single animatable\n * value. Currently, updatedAt and current are unused. The\n * long term idea is to use this to minimise the number\n * of DOM reads, and to abstract the DOM interactions here.\n */\nclass MotionValue {\n    setAnimation(animation) {\n        this.animation = animation;\n        animation === null || animation === void 0 ? void 0 : animation.finished.then(() => this.clearAnimation()).catch(() => { });\n    }\n    clearAnimation() {\n        this.animation = this.generator = undefined;\n    }\n}\n\nexport { MotionValue };\n","import { MotionValue } from '@motionone/types';\n\nconst data = new WeakMap();\nfunction getAnimationData(element) {\n    if (!data.has(element)) {\n        data.set(element, {\n            transforms: [],\n            values: new Map(),\n        });\n    }\n    return data.get(element);\n}\nfunction getMotionValue(motionValues, name) {\n    if (!motionValues.has(name)) {\n        motionValues.set(name, new MotionValue());\n    }\n    return motionValues.get(name);\n}\n\nexport { getAnimationData, getMotionValue };\n","import { noopReturn, addUniqueItem } from '@motionone/utils';\nimport { getAnimationData } from '../data.es.js';\n\n/**\n * A list of all transformable axes. We'll use this list to generated a version\n * of each axes for each transform.\n */\nconst axes = [\"\", \"X\", \"Y\", \"Z\"];\n/**\n * An ordered array of each transformable value. By default, transform values\n * will be sorted to this order.\n */\nconst order = [\"translate\", \"scale\", \"rotate\", \"skew\"];\nconst transformAlias = {\n    x: \"translateX\",\n    y: \"translateY\",\n    z: \"translateZ\",\n};\nconst rotation = {\n    syntax: \"<angle>\",\n    initialValue: \"0deg\",\n    toDefaultUnit: (v) => v + \"deg\",\n};\nconst baseTransformProperties = {\n    translate: {\n        syntax: \"<length-percentage>\",\n        initialValue: \"0px\",\n        toDefaultUnit: (v) => v + \"px\",\n    },\n    rotate: rotation,\n    scale: {\n        syntax: \"<number>\",\n        initialValue: 1,\n        toDefaultUnit: noopReturn,\n    },\n    skew: rotation,\n};\nconst transformDefinitions = new Map();\nconst asTransformCssVar = (name) => `--motion-${name}`;\n/**\n * Generate a list of every possible transform key\n */\nconst transforms = [\"x\", \"y\", \"z\"];\norder.forEach((name) => {\n    axes.forEach((axis) => {\n        transforms.push(name + axis);\n        transformDefinitions.set(asTransformCssVar(name + axis), baseTransformProperties[name]);\n    });\n});\n/**\n * A function to use with Array.sort to sort transform keys by their default order.\n */\nconst compareTransformOrder = (a, b) => transforms.indexOf(a) - transforms.indexOf(b);\n/**\n * Provide a quick way to check if a string is the name of a transform\n */\nconst transformLookup = new Set(transforms);\nconst isTransform = (name) => transformLookup.has(name);\nconst addTransformToElement = (element, name) => {\n    // Map x to translateX etc\n    if (transformAlias[name])\n        name = transformAlias[name];\n    const { transforms } = getAnimationData(element);\n    addUniqueItem(transforms, name);\n    /**\n     * TODO: An optimisation here could be to cache the transform in element data\n     * and only update if this has changed.\n     */\n    element.style.transform = buildTransformTemplate(transforms);\n};\nconst buildTransformTemplate = (transforms) => transforms\n    .sort(compareTransformOrder)\n    .reduce(transformListToString, \"\")\n    .trim();\nconst transformListToString = (template, name) => `${template} ${name}(var(${asTransformCssVar(name)}))`;\n\nexport { addTransformToElement, asTransformCssVar, axes, buildTransformTemplate, compareTransformOrder, isTransform, transformAlias, transformDefinitions };\n","import { transformDefinitions } from './transforms.es.js';\n\nconst isCssVar = (name) => name.startsWith(\"--\");\nconst registeredProperties = new Set();\nfunction registerCssVariable(name) {\n    if (registeredProperties.has(name))\n        return;\n    registeredProperties.add(name);\n    try {\n        const { syntax, initialValue } = transformDefinitions.has(name)\n            ? transformDefinitions.get(name)\n            : {};\n        CSS.registerProperty({\n            name,\n            inherits: false,\n            syntax,\n            initialValue,\n        });\n    }\n    catch (e) { }\n}\n\nexport { isCssVar, registerCssVariable, registeredProperties };\n","const testAnimation = (keyframes, options) => document.createElement(\"div\").animate(keyframes, options);\nconst featureTests = {\n    cssRegisterProperty: () => typeof CSS !== \"undefined\" &&\n        Object.hasOwnProperty.call(CSS, \"registerProperty\"),\n    waapi: () => Object.hasOwnProperty.call(Element.prototype, \"animate\"),\n    partialKeyframes: () => {\n        try {\n            testAnimation({ opacity: [1] });\n        }\n        catch (e) {\n            return false;\n        }\n        return true;\n    },\n    finished: () => Boolean(testAnimation({ opacity: [0, 1] }, { duration: 0.001 }).finished),\n    linearEasing: () => {\n        try {\n            testAnimation({ opacity: 0 }, { easing: \"linear(0, 1)\" });\n        }\n        catch (e) {\n            return false;\n        }\n        return true;\n    },\n};\nconst results = {};\nconst supports = {};\nfor (const key in featureTests) {\n    supports[key] = () => {\n        if (results[key] === undefined)\n            results[key] = featureTests[key]();\n        return results[key];\n    };\n}\n\nexport { supports };\n","import { isFunction, defaults, isCubicBezier, progress } from '@motionone/utils';\nimport { supports } from './feature-detection.es.js';\n\n// Create a linear easing point for every x second\nconst resolution = 0.015;\nconst generateLinearEasingPoints = (easing, duration) => {\n    let points = \"\";\n    const numPoints = Math.round(duration / resolution);\n    for (let i = 0; i < numPoints; i++) {\n        points += easing(progress(0, numPoints - 1, i)) + \", \";\n    }\n    return points.substring(0, points.length - 2);\n};\nconst convertEasing = (easing, duration) => {\n    if (isFunction(easing)) {\n        return supports.linearEasing()\n            ? `linear(${generateLinearEasingPoints(easing, duration)})`\n            : defaults.easing;\n    }\n    else {\n        return isCubicBezier(easing) ? cubicBezierAsString(easing) : easing;\n    }\n};\nconst cubicBezierAsString = ([a, b, c, d]) => `cubic-bezier(${a}, ${b}, ${c}, ${d})`;\n\nexport { convertEasing, cubicBezierAsString, generateLinearEasingPoints };\n","function hydrateKeyframes(keyframes, readInitialValue) {\n    for (let i = 0; i < keyframes.length; i++) {\n        if (keyframes[i] === null) {\n            keyframes[i] = i ? keyframes[i - 1] : readInitialValue();\n        }\n    }\n    return keyframes;\n}\nconst keyframesList = (keyframes) => Array.isArray(keyframes) ? keyframes : [keyframes];\n\nexport { hydrateKeyframes, keyframesList };\n","import { isTransform, asTransformCssVar, transformAlias } from './transforms.es.js';\n\nfunction getStyleName(key) {\n    if (transformAlias[key])\n        key = transformAlias[key];\n    return isTransform(key) ? asTransformCssVar(key) : key;\n}\n\nexport { getStyleName };\n","import { isCssVar } from './utils/css-var.es.js';\nimport { getStyleName } from './utils/get-style-name.es.js';\nimport { transformDefinitions } from './utils/transforms.es.js';\n\nconst style = {\n    get: (element, name) => {\n        name = getStyleName(name);\n        let value = isCssVar(name)\n            ? element.style.getPropertyValue(name)\n            : getComputedStyle(element)[name];\n        if (!value && value !== 0) {\n            const definition = transformDefinitions.get(name);\n            if (definition)\n                value = definition.initialValue;\n        }\n        return value;\n    },\n    set: (element, name, value) => {\n        name = getStyleName(name);\n        if (isCssVar(name)) {\n            element.style.setProperty(name, value);\n        }\n        else {\n            element.style[name] = value;\n        }\n    },\n};\n\nexport { style };\n","function stopAnimation(animation, needsCommit = true) {\n    if (!animation || animation.playState === \"finished\")\n        return;\n    // Suppress error thrown by WAAPI\n    try {\n        if (animation.stop) {\n            animation.stop();\n        }\n        else {\n            needsCommit && animation.commitStyles();\n            animation.cancel();\n        }\n    }\n    catch (e) { }\n}\n\nexport { stopAnimation };\n","import { noopReturn, isString } from '@motionone/utils';\n\nfunction getUnitConverter(keyframes, definition) {\n    var _a;\n    let toUnit = (definition === null || definition === void 0 ? void 0 : definition.toDefaultUnit) || noopReturn;\n    const finalKeyframe = keyframes[keyframes.length - 1];\n    if (isString(finalKeyframe)) {\n        const unit = ((_a = finalKeyframe.match(/(-?[\\d.]+)([a-z%]*)/)) === null || _a === void 0 ? void 0 : _a[2]) || \"\";\n        if (unit)\n            toUnit = (value) => value + unit;\n    }\n    return toUnit;\n}\n\nexport { getUnitConverter };\n","import { getAnimationData, getMotionValue } from './data.es.js';\nimport { isCssVar, registerCssVariable } from './utils/css-var.es.js';\nimport { defaults, isEasingGenerator, isFunction, isEasingList, isNumber, time, noop } from '@motionone/utils';\nimport { isTransform, addTransformToElement, transformDefinitions } from './utils/transforms.es.js';\nimport { convertEasing } from './utils/easing.es.js';\nimport { supports } from './utils/feature-detection.es.js';\nimport { hydrateKeyframes, keyframesList } from './utils/keyframes.es.js';\nimport { style } from './style.es.js';\nimport { getStyleName } from './utils/get-style-name.es.js';\nimport { stopAnimation } from './utils/stop-animation.es.js';\nimport { getUnitConverter } from './utils/get-unit.es.js';\n\nfunction getDevToolsRecord() {\n    return window.__MOTION_DEV_TOOLS_RECORD;\n}\nfunction animateStyle(element, key, keyframesDefinition, options = {}, AnimationPolyfill) {\n    const record = getDevToolsRecord();\n    const isRecording = options.record !== false && record;\n    let animation;\n    let { duration = defaults.duration, delay = defaults.delay, endDelay = defaults.endDelay, repeat = defaults.repeat, easing = defaults.easing, persist = false, direction, offset, allowWebkitAcceleration = false, autoplay = true, } = options;\n    const data = getAnimationData(element);\n    const valueIsTransform = isTransform(key);\n    let canAnimateNatively = supports.waapi();\n    /**\n     * If this is an individual transform, we need to map its\n     * key to a CSS variable and update the element's transform style\n     */\n    valueIsTransform && addTransformToElement(element, key);\n    const name = getStyleName(key);\n    const motionValue = getMotionValue(data.values, name);\n    /**\n     * Get definition of value, this will be used to convert numerical\n     * keyframes into the default value type.\n     */\n    const definition = transformDefinitions.get(name);\n    /**\n     * Stop the current animation, if any. Because this will trigger\n     * commitStyles (DOM writes) and we might later trigger DOM reads,\n     * this is fired now and we return a factory function to create\n     * the actual animation that can get called in batch,\n     */\n    stopAnimation(motionValue.animation, !(isEasingGenerator(easing) && motionValue.generator) &&\n        options.record !== false);\n    /**\n     * Batchable factory function containing all DOM reads.\n     */\n    return () => {\n        const readInitialValue = () => { var _a, _b; return (_b = (_a = style.get(element, name)) !== null && _a !== void 0 ? _a : definition === null || definition === void 0 ? void 0 : definition.initialValue) !== null && _b !== void 0 ? _b : 0; };\n        /**\n         * Replace null values with the previous keyframe value, or read\n         * it from the DOM if it's the first keyframe.\n         */\n        let keyframes = hydrateKeyframes(keyframesList(keyframesDefinition), readInitialValue);\n        /**\n         * Detect unit type of keyframes.\n         */\n        const toUnit = getUnitConverter(keyframes, definition);\n        if (isEasingGenerator(easing)) {\n            const custom = easing.createAnimation(keyframes, key !== \"opacity\", readInitialValue, name, motionValue);\n            easing = custom.easing;\n            keyframes = custom.keyframes || keyframes;\n            duration = custom.duration || duration;\n        }\n        /**\n         * If this is a CSS variable we need to register it with the browser\n         * before it can be animated natively. We also set it with setProperty\n         * rather than directly onto the element.style object.\n         */\n        if (isCssVar(name)) {\n            if (supports.cssRegisterProperty()) {\n                registerCssVariable(name);\n            }\n            else {\n                canAnimateNatively = false;\n            }\n        }\n        /**\n         * If we've been passed a custom easing function, and this browser\n         * does **not** support linear() easing, and the value is a transform\n         * (and thus a pure number) we can still support the custom easing\n         * by falling back to the animation polyfill.\n         */\n        if (valueIsTransform &&\n            !supports.linearEasing() &&\n            (isFunction(easing) || (isEasingList(easing) && easing.some(isFunction)))) {\n            canAnimateNatively = false;\n        }\n        /**\n         * If we can animate this value with WAAPI, do so.\n         */\n        if (canAnimateNatively) {\n            /**\n             * Convert numbers to default value types. Currently this only supports\n             * transforms but it could also support other value types.\n             */\n            if (definition) {\n                keyframes = keyframes.map((value) => isNumber(value) ? definition.toDefaultUnit(value) : value);\n            }\n            /**\n             * If this browser doesn't support partial/implicit keyframes we need to\n             * explicitly provide one.\n             */\n            if (keyframes.length === 1 &&\n                (!supports.partialKeyframes() || isRecording)) {\n                keyframes.unshift(readInitialValue());\n            }\n            const animationOptions = {\n                delay: time.ms(delay),\n                duration: time.ms(duration),\n                endDelay: time.ms(endDelay),\n                easing: !isEasingList(easing)\n                    ? convertEasing(easing, duration)\n                    : undefined,\n                direction,\n                iterations: repeat + 1,\n                fill: \"both\",\n            };\n            animation = element.animate({\n                [name]: keyframes,\n                offset,\n                easing: isEasingList(easing)\n                    ? easing.map((thisEasing) => convertEasing(thisEasing, duration))\n                    : undefined,\n            }, animationOptions);\n            /**\n             * Polyfill finished Promise in browsers that don't support it\n             */\n            if (!animation.finished) {\n                animation.finished = new Promise((resolve, reject) => {\n                    animation.onfinish = resolve;\n                    animation.oncancel = reject;\n                });\n            }\n            const target = keyframes[keyframes.length - 1];\n            animation.finished\n                .then(() => {\n                if (persist)\n                    return;\n                // Apply styles to target\n                style.set(element, name, target);\n                // Ensure fill modes don't persist\n                animation.cancel();\n            })\n                .catch(noop);\n            /**\n             * This forces Webkit to run animations on the main thread by exploiting\n             * this condition:\n             * https://trac.webkit.org/browser/webkit/trunk/Source/WebCore/platform/graphics/ca/GraphicsLayerCA.cpp?rev=281238#L1099\n             *\n             * This fixes Webkit's timing bugs, like accelerated animations falling\n             * out of sync with main thread animations and massive delays in starting\n             * accelerated animations in WKWebView.\n             */\n            if (!allowWebkitAcceleration)\n                animation.playbackRate = 1.000001;\n            /**\n             * If we can't animate the value natively then we can fallback to the numbers-only\n             * polyfill for transforms.\n             */\n        }\n        else if (AnimationPolyfill && valueIsTransform) {\n            /**\n             * If any keyframe is a string (because we measured it from the DOM), we need to convert\n             * it into a number before passing to the Animation polyfill.\n             */\n            keyframes = keyframes.map((value) => typeof value === \"string\" ? parseFloat(value) : value);\n            /**\n             * If we only have a single keyframe, we need to create an initial keyframe by reading\n             * the current value from the DOM.\n             */\n            if (keyframes.length === 1) {\n                keyframes.unshift(parseFloat(readInitialValue()));\n            }\n            animation = new AnimationPolyfill((latest) => {\n                style.set(element, name, toUnit ? toUnit(latest) : latest);\n            }, keyframes, Object.assign(Object.assign({}, options), { duration,\n                easing }));\n        }\n        else {\n            const target = keyframes[keyframes.length - 1];\n            style.set(element, name, definition && isNumber(target)\n                ? definition.toDefaultUnit(target)\n                : target);\n        }\n        if (isRecording) {\n            record(element, key, keyframes, {\n                duration,\n                delay: delay,\n                easing,\n                repeat,\n                offset,\n            }, \"motion-one\");\n        }\n        motionValue.setAnimation(animation);\n        if (animation && !autoplay)\n            animation.pause();\n        return animation;\n    };\n}\n\nexport { animateStyle };\n","const getOptions = (options, key) => \n/**\n * TODO: Make test for this\n * Always return a new object otherwise delay is overwritten by results of stagger\n * and this results in no stagger\n */\noptions[key] ? Object.assign(Object.assign({}, options), options[key]) : Object.assign({}, options);\n\nexport { getOptions };\n","function resolveElements(elements, selectorCache) {\n    var _a;\n    if (typeof elements === \"string\") {\n        if (selectorCache) {\n            (_a = selectorCache[elements]) !== null && _a !== void 0 ? _a : (selectorCache[elements] = document.querySelectorAll(elements));\n            elements = selectorCache[elements];\n        }\n        else {\n            elements = document.querySelectorAll(elements);\n        }\n    }\n    else if (elements instanceof Element) {\n        elements = [elements];\n    }\n    /**\n     * Return an empty array\n     */\n    return Array.from(elements || []);\n}\n\nexport { resolveElements };\n","import { defaults, noop, time } from '@motionone/utils';\nimport { stopAnimation } from './stop-animation.es.js';\n\nconst createAnimation = (factory) => factory();\nconst withControls = (animationFactory, options, duration = defaults.duration) => {\n    return new Proxy({\n        animations: animationFactory.map(createAnimation).filter(Boolean),\n        duration,\n        options,\n    }, controls);\n};\n/**\n * TODO:\n * Currently this returns the first animation, ideally it would return\n * the first active animation.\n */\nconst getActiveAnimation = (state) => state.animations[0];\nconst controls = {\n    get: (target, key) => {\n        const activeAnimation = getActiveAnimation(target);\n        switch (key) {\n            case \"duration\":\n                return target.duration;\n            case \"currentTime\":\n                return time.s((activeAnimation === null || activeAnimation === void 0 ? void 0 : activeAnimation[key]) || 0);\n            case \"playbackRate\":\n            case \"playState\":\n                return activeAnimation === null || activeAnimation === void 0 ? void 0 : activeAnimation[key];\n            case \"finished\":\n                if (!target.finished) {\n                    target.finished = Promise.all(target.animations.map(selectFinished)).catch(noop);\n                }\n                return target.finished;\n            case \"stop\":\n                return () => {\n                    target.animations.forEach((animation) => stopAnimation(animation));\n                };\n            case \"forEachNative\":\n                /**\n                 * This is for internal use only, fire a callback for each\n                 * underlying animation.\n                 */\n                return (callback) => {\n                    target.animations.forEach((animation) => callback(animation, target));\n                };\n            default:\n                return typeof (activeAnimation === null || activeAnimation === void 0 ? void 0 : activeAnimation[key]) === \"undefined\"\n                    ? undefined\n                    : () => target.animations.forEach((animation) => animation[key]());\n        }\n    },\n    set: (target, key, value) => {\n        switch (key) {\n            case \"currentTime\":\n                value = time.ms(value);\n            // Fall-through\n            case \"playbackRate\":\n                for (let i = 0; i < target.animations.length; i++) {\n                    target.animations[i][key] = value;\n                }\n                return true;\n        }\n        return false;\n    },\n};\nconst selectFinished = (animation) => animation.finished;\n\nexport { controls, withControls };\n","import { isNumber, isFunction } from '@motionone/utils';\nimport { getEasingFunction } from '@motionone/animation';\n\nfunction stagger(duration = 0.1, { start = 0, from = 0, easing } = {}) {\n    return (i, total) => {\n        const fromIndex = isNumber(from) ? from : getFromIndex(from, total);\n        const distance = Math.abs(fromIndex - i);\n        let delay = duration * distance;\n        if (easing) {\n            const maxDelay = total * duration;\n            const easingFunction = getEasingFunction(easing);\n            delay = easingFunction(delay / maxDelay) * maxDelay;\n        }\n        return start + delay;\n    };\n}\nfunction getFromIndex(from, total) {\n    if (from === \"first\") {\n        return 0;\n    }\n    else {\n        const lastIndex = total - 1;\n        return from === \"last\" ? lastIndex : lastIndex / 2;\n    }\n}\nfunction resolveOption(option, i, total) {\n    return isFunction(option) ? option(i, total) : option;\n}\n\nexport { getFromIndex, resolveOption, stagger };\n","import { invariant } from 'hey-listen';\nimport { animateStyle } from './animate-style.es.js';\nimport { getOptions } from './utils/options.es.js';\nimport { resolveElements } from '../utils/resolve-elements.es.js';\nimport { withControls } from './utils/controls.es.js';\nimport { resolveOption } from '../utils/stagger.es.js';\n\nfunction createAnimate(AnimatePolyfill) {\n    return function animate(elements, keyframes, options = {}) {\n        elements = resolveElements(elements);\n        const numElements = elements.length;\n        invariant(Boolean(numElements), \"No valid element provided.\");\n        invariant(Boolean(keyframes), \"No keyframes defined.\");\n        /**\n         * Create and start new animations\n         */\n        const animationFactories = [];\n        for (let i = 0; i < numElements; i++) {\n            const element = elements[i];\n            for (const key in keyframes) {\n                const valueOptions = getOptions(options, key);\n                valueOptions.delay = resolveOption(valueOptions.delay, i, numElements);\n                const animation = animateStyle(element, key, keyframes[key], valueOptions, AnimatePolyfill);\n                animationFactories.push(animation);\n            }\n        }\n        return withControls(animationFactories, options, \n        /**\n         * TODO:\n         * If easing is set to spring or glide, duration will be dynamically\n         * generated. Ideally we would dynamically generate this from\n         * animation.effect.getComputedTiming().duration but this isn't\n         * supported in iOS13 or our number polyfill. Perhaps it's possible\n         * to Proxy animations returned from animateStyle that has duration\n         * as a getter.\n         */\n        options.duration);\n    };\n}\n\nexport { createAnimate };\n","import { Animation } from '@motionone/animation';\nimport { createAnimate } from './create-animate.es.js';\n\nconst animate = createAnimate(Animation);\n\nexport { animate };\n"],"names":["addUniqueItem","array","item","clamp","min","max","v","defaults","isNumber","value","isEasingList","easing","wrap","rangeSize","getEasingForSegment","i","mix","progress","noop","noopReturn","fillOffset","offset","remaining","offsetProgress","defaultOffset","length","interpolate","output","input","remainder","t","progressInRange","isCubicBezier","isEasingGenerator","isFunction","isString","time","seconds","milliseconds","calcBezier","a1","a2","subdivisionPrecision","subdivisionMaxIterations","binarySubdivide","x","lowerBound","upperBound","mX1","mX2","currentX","currentT","cubicBezier","mY1","mY2","getTForX","aX","steps","direction","expanded","rounded","namedEasings","functionArgsRegex","getEasingFunction","definition","args","argsArray","Animation","keyframes","initialDuration","delay","endDelay","repeat","autoplay","resolve","reject","custom","interpolate$1","timestamp","_a","currentIteration","iterationProgress","iterationIsOdd","p","latest","now","duration","rate","MotionValue","animation","data","getAnimationData","element","getMotionValue","motionValues","name","axes","order","transformAlias","rotation","baseTransformProperties","transformDefinitions","asTransformCssVar","transforms","axis","compareTransformOrder","a","b","transformLookup","isTransform","addTransformToElement","buildTransformTemplate","transformListToString","template","isCssVar","registeredProperties","registerCssVariable","syntax","initialValue","testAnimation","options","featureTests","results","supports","key","resolution","generateLinearEasingPoints","points","numPoints","convertEasing","cubicBezierAsString","c","d","hydrateKeyframes","readInitialValue","keyframesList","getStyleName","style","stopAnimation","needsCommit","getUnitConverter","toUnit","finalKeyframe","unit","getDevToolsRecord","animateStyle","keyframesDefinition","AnimationPolyfill","record","isRecording","persist","allowWebkitAcceleration","valueIsTransform","canAnimateNatively","motionValue","_b","animationOptions","thisEasing","target","getOptions","resolveElements","elements","selectorCache","createAnimation","factory","withControls","animationFactory","controls","getActiveAnimation","state","activeAnimation","selectFinished","callback","resolveOption","option","total","createAnimate","AnimatePolyfill","numElements","animationFactories","valueOptions","animate"],"mappings":"AAAA,SAASA,GAAcC,EAAOC,EAAM,CAChCD,EAAM,QAAQC,CAAI,IAAM,IAAMD,EAAM,KAAKC,CAAI,CACjD,CCFA,MAAMC,GAAQ,CAACC,EAAKC,EAAKC,IAAM,KAAK,IAAI,KAAK,IAAIA,EAAGF,CAAG,EAAGC,CAAG,ECAvDE,EAAW,CACb,SAAU,GACV,MAAO,EACP,SAAU,EACV,OAAQ,EACR,OAAQ,MACZ,ECNMC,EAAYC,GAAU,OAAOA,GAAU,SCEvCC,EAAgBC,GAAW,MAAM,QAAQA,CAAM,GAAK,CAACH,EAASG,EAAO,CAAC,CAAC,ECFvEC,GAAO,CAACR,EAAKC,EAAKC,IAAM,CAC1B,MAAMO,EAAYR,EAAMD,EACxB,QAAWE,EAAIF,GAAOS,EAAaA,GAAaA,EAAaT,CACjE,ECAA,SAASU,GAAoBH,EAAQI,EAAG,CACpC,OAAOL,EAAaC,CAAM,EACpBA,EAAOC,GAAK,EAAGD,EAAO,OAAQI,CAAC,CAAC,EAChCJ,CACV,CCPA,MAAMK,GAAM,CAACZ,EAAKC,EAAKY,IAAa,CAACA,EAAWb,EAAMa,EAAWZ,EAAMD,ECAjEc,GAAO,IAAM,CAAA,EACbC,EAAcb,GAAMA,ECDpBW,EAAW,CAACb,EAAKC,EAAKI,IAAUJ,EAAMD,IAAQ,EAAI,GAAKK,EAAQL,IAAQC,EAAMD,GCGnF,SAASgB,GAAWC,EAAQC,EAAW,CACnC,MAAMlB,EAAMiB,EAAOA,EAAO,OAAS,CAAC,EACpC,QAASN,EAAI,EAAGA,GAAKO,EAAWP,IAAK,CACjC,MAAMQ,EAAiBN,EAAS,EAAGK,EAAWP,CAAC,EAC/CM,EAAO,KAAKL,GAAIZ,EAAK,EAAGmB,CAAc,CAAC,CAC1C,CACL,CACA,SAASC,GAAcC,EAAQ,CAC3B,MAAMJ,EAAS,CAAC,CAAC,EACjB,OAAAD,GAAWC,EAAQI,EAAS,CAAC,EACtBJ,CACX,CCPA,SAASK,GAAYC,EAAQC,EAAQJ,GAAcG,EAAO,MAAM,EAAGhB,EAASQ,EAAY,CACpF,MAAMM,EAASE,EAAO,OAOhBE,EAAYJ,EAASG,EAAM,OACjC,OAAAC,EAAY,GAAKT,GAAWQ,EAAOC,CAAS,EACpCC,GAAM,CACV,IAAIf,EAAI,EACR,KAAOA,EAAIU,EAAS,GACZ,EAAAK,EAAIF,EAAMb,EAAI,CAAC,GADAA,IACnB,CAGJ,IAAIgB,EAAkB5B,GAAM,EAAG,EAAGc,EAASW,EAAMb,CAAC,EAAGa,EAAMb,EAAI,CAAC,EAAGe,CAAC,CAAC,EAErE,OAAAC,EADsBjB,GAAoBH,EAAQI,CAAC,EACnBgB,CAAe,EACxCf,GAAIW,EAAOZ,CAAC,EAAGY,EAAOZ,EAAI,CAAC,EAAGgB,CAAe,CAC5D,CACA,CC1BA,MAAMC,GAAiBrB,GAAW,MAAM,QAAQA,CAAM,GAAKH,EAASG,EAAO,CAAC,CAAC,ECFvEsB,EAAqBtB,GAAW,OAAOA,GAAW,UACpD,EAAQA,EAAO,gBCDbuB,EAAczB,GAAU,OAAOA,GAAU,WCAzC0B,GAAY1B,GAAU,OAAOA,GAAU,SCAvC2B,EAAO,CACT,GAAKC,GAAYA,EAAU,IAC3B,EAAIC,GAAiBA,EAAe,GACxC,ECoBMC,GAAa,CAAC,EAAGC,EAAIC,OAAU,EAAM,EAAMA,EAAK,EAAMD,GAAM,GAAK,EAAMC,EAAK,EAAMD,IAAO,EAAI,EAAMA,GAAM,EACzGE,GAAuB,KACvBC,GAA2B,GACjC,SAASC,GAAgBC,EAAGC,EAAYC,EAAYC,EAAKC,EAAK,CAC1D,IAAIC,EACAC,EACApC,EAAI,EACR,GACIoC,EAAWL,GAAcC,EAAaD,GAAc,EACpDI,EAAWX,GAAWY,EAAUH,EAAKC,CAAG,EAAIJ,EACxCK,EAAW,EACXH,EAAaI,EAGbL,EAAaK,QAEZ,KAAK,IAAID,CAAQ,EAAIR,IAC1B,EAAE3B,EAAI4B,IACV,OAAOQ,CACX,CACA,SAASC,EAAYJ,EAAKK,EAAKJ,EAAKK,EAAK,CAErC,GAAIN,IAAQK,GAAOJ,IAAQK,EACvB,OAAOnC,EACX,MAAMoC,EAAYC,GAAOZ,GAAgBY,EAAI,EAAG,EAAGR,EAAKC,CAAG,EAE3D,OAAQnB,GAAMA,IAAM,GAAKA,IAAM,EAAIA,EAAIS,GAAWgB,EAASzB,CAAC,EAAGuB,EAAKC,CAAG,CAC3E,CChDA,MAAMG,GAAQ,CAACA,EAAOC,EAAY,QAAWzC,GAAa,CACtDA,EACIyC,IAAc,MACR,KAAK,IAAIzC,EAAU,IAAK,EACxB,KAAK,IAAIA,EAAU,IAAK,EAClC,MAAM0C,EAAW1C,EAAWwC,EACtBG,EAAUF,IAAc,MAAQ,KAAK,MAAMC,CAAQ,EAAI,KAAK,KAAKA,CAAQ,EAC/E,OAAOxD,GAAM,EAAG,EAAGyD,EAAUH,CAAK,CACtC,ECPMI,EAAe,CACjB,KAAMT,EAAY,IAAM,GAAK,IAAM,CAAG,EACtC,UAAWA,EAAY,IAAM,EAAK,EAAK,CAAG,EAC1C,cAAeA,EAAY,IAAM,EAAK,IAAM,CAAG,EAC/C,WAAYA,EAAY,EAAK,EAAK,IAAM,CAAG,CAC/C,EACMU,GAAoB,YAC1B,SAASC,EAAkBC,EAAY,CAEnC,GAAI9B,EAAW8B,CAAU,EACrB,OAAOA,EAEX,GAAIhC,GAAcgC,CAAU,EACxB,OAAOZ,EAAY,GAAGY,CAAU,EAEpC,GAAIH,EAAaG,CAAU,EACvB,OAAOH,EAAaG,CAAU,EAElC,GAAIA,EAAW,WAAW,OAAO,EAAG,CAChC,MAAMC,EAAOH,GAAkB,KAAKE,CAAU,EAC9C,GAAIC,EAAM,CACN,MAAMC,EAAYD,EAAK,CAAC,EAAE,MAAM,GAAG,EACnC,OAAOR,GAAM,WAAWS,EAAU,CAAC,CAAC,EAAGA,EAAU,CAAC,EAAE,KAAI,CAAE,CAC7D,CACJ,CACD,OAAO/C,CACX,CC1BA,MAAMgD,EAAU,CACZ,YAAYxC,EAAQyC,EAAY,CAAC,EAAG,CAAC,EAAG,CAAE,OAAAzD,EAAQ,SAAU0D,EAAkB9D,EAAS,SAAU,MAAA+D,EAAQ/D,EAAS,MAAO,SAAAgE,EAAWhE,EAAS,SAAU,OAAAiE,EAASjE,EAAS,OAAQ,OAAAc,EAAQ,UAAAqC,EAAY,SAAU,SAAAe,EAAW,EAAI,EAAM,CAAA,EAAI,CAepO,GAdA,KAAK,UAAY,KACjB,KAAK,KAAO,EACZ,KAAK,EAAI,EACT,KAAK,gBAAkB,KACvB,KAAK,OAAStD,EACd,KAAK,SAAW,EAChB,KAAK,cAAgB,EACrB,KAAK,OAAS,EACd,KAAK,UAAY,OACjB,KAAK,SAAW,IAAI,QAAQ,CAACuD,EAASC,IAAW,CAC7C,KAAK,QAAUD,EACf,KAAK,OAASC,CAC1B,CAAS,EACDhE,EAASA,GAAUJ,EAAS,OACxB0B,EAAkBtB,CAAM,EAAG,CAC3B,MAAMiE,EAASjE,EAAO,gBAAgByD,CAAS,EAC/CzD,EAASiE,EAAO,OAChBR,EAAYQ,EAAO,WAAaR,EAChCC,EAAkBO,EAAO,UAAYP,CACxC,CACD,KAAK,OAASG,EACd,KAAK,OAAS9D,EAAaC,CAAM,EAAIQ,EAAa4C,EAAkBpD,CAAM,EAC1E,KAAK,eAAe0D,CAAe,EACnC,MAAMQ,EAAgBnD,GAAY0C,EAAW/C,EAAQX,EAAaC,CAAM,EAAIA,EAAO,IAAIoD,CAAiB,EAAI5C,CAAU,EACtH,KAAK,KAAQ2D,GAAc,CACvB,IAAIC,EAEJT,EAAQA,EACR,IAAIxC,EAAI,EACJ,KAAK,YAAc,OACnBA,EAAI,KAAK,UAGTA,GAAKgD,EAAY,KAAK,WAAa,KAAK,KAE5C,KAAK,EAAIhD,EAETA,GAAK,IAELA,EAAI,KAAK,IAAIA,EAAIwC,EAAO,CAAC,EAKrB,KAAK,YAAc,YAAc,KAAK,YAAc,SACpDxC,EAAI,KAAK,eAOb,MAAMb,EAAWa,EAAI,KAAK,SAM1B,IAAIkD,EAAmB,KAAK,MAAM/D,CAAQ,EAKtCgE,EAAoBhE,EAAW,EAC/B,CAACgE,GAAqBhE,GAAY,IAClCgE,EAAoB,GAMxBA,IAAsB,GAAKD,IAI3B,MAAME,EAAiBF,EAAmB,GACtCtB,IAAc,WACbA,IAAc,aAAewB,GAC7BxB,IAAc,qBAAuB,CAACwB,KACvCD,EAAoB,EAAIA,GAE5B,MAAME,EAAIrD,GAAK,KAAK,cAAgB,EAAI,KAAK,IAAImD,EAAmB,CAAC,EAC/DG,EAASP,EAAc,KAAK,OAAOM,CAAC,CAAC,EAC3CxD,EAAOyD,CAAM,EACe,KAAK,YAAc,SAC1C,KAAK,YAAc,YAActD,GAAK,KAAK,cAAgByC,IAE5D,KAAK,UAAY,YAChBQ,EAAK,KAAK,WAAa,MAAQA,IAAO,QAAkBA,EAAG,KAAK,KAAMK,CAAM,GAExE,KAAK,YAAc,SACxB,KAAK,eAAiB,sBAAsB,KAAK,IAAI,EAErE,EACYX,GACA,KAAK,KAAI,CAChB,CACD,MAAO,CACH,MAAMY,EAAM,YAAY,MACxB,KAAK,UAAY,UACb,KAAK,YAAc,OACnB,KAAK,UAAYA,EAAM,KAAK,UAEtB,KAAK,YACX,KAAK,UAAYA,GAErB,KAAK,gBAAkB,KAAK,UAC5B,KAAK,UAAY,OACjB,KAAK,eAAiB,sBAAsB,KAAK,IAAI,CACxD,CACD,OAAQ,CACJ,KAAK,UAAY,SACjB,KAAK,UAAY,KAAK,CACzB,CACD,QAAS,CACL,KAAK,UAAY,WACjB,KAAK,KAAK,CAAC,CACd,CACD,MAAO,CACH,IAAIN,EACJ,KAAK,UAAY,OACb,KAAK,iBAAmB,QACxB,qBAAqB,KAAK,cAAc,GAE3CA,EAAK,KAAK,UAAY,MAAQA,IAAO,QAAkBA,EAAG,KAAK,KAAM,EAAK,CAC9E,CACD,QAAS,CACL,KAAK,KAAI,EACT,KAAK,KAAK,KAAK,eAAe,CACjC,CACD,SAAU,CACN,KAAK,MAAQ,EAChB,CACD,cAAe,CAAG,CAClB,eAAeO,EAAU,CACrB,KAAK,SAAWA,EAChB,KAAK,cAAgBA,GAAY,KAAK,OAAS,EAClD,CACD,IAAI,aAAc,CACd,OAAO,KAAK,CACf,CACD,IAAI,YAAYxD,EAAG,CACX,KAAK,YAAc,QAAa,KAAK,OAAS,EAC9C,KAAK,UAAYA,EAGjB,KAAK,UAAY,YAAY,IAAK,EAAGA,EAAI,KAAK,IAErD,CACD,IAAI,cAAe,CACf,OAAO,KAAK,IACf,CACD,IAAI,aAAayD,EAAM,CACnB,KAAK,KAAOA,CACf,CACL,CC1JA,MAAMC,EAAY,CACd,aAAaC,EAAW,CACpB,KAAK,UAAYA,EACjBA,GAAc,MAAwCA,EAAU,SAAS,KAAK,IAAM,KAAK,eAAc,CAAE,EAAE,MAAM,IAAM,CAAA,CAAG,CAC7H,CACD,gBAAiB,CACb,KAAK,UAAY,KAAK,UAAY,MACrC,CACL,CCZA,MAAMC,EAAO,IAAI,QACjB,SAASC,GAAiBC,EAAS,CAC/B,OAAKF,EAAK,IAAIE,CAAO,GACjBF,EAAK,IAAIE,EAAS,CACd,WAAY,CAAE,EACd,OAAQ,IAAI,GACxB,CAAS,EAEEF,EAAK,IAAIE,CAAO,CAC3B,CACA,SAASC,GAAeC,EAAcC,EAAM,CACxC,OAAKD,EAAa,IAAIC,CAAI,GACtBD,EAAa,IAAIC,EAAM,IAAIP,EAAa,EAErCM,EAAa,IAAIC,CAAI,CAChC,CCVA,MAAMC,GAAO,CAAC,GAAI,IAAK,IAAK,GAAG,EAKzBC,GAAQ,CAAC,YAAa,QAAS,SAAU,MAAM,EAC/CC,EAAiB,CACnB,EAAG,aACH,EAAG,aACH,EAAG,YACP,EACMC,EAAW,CACb,OAAQ,UACR,aAAc,OACd,cAAgB7F,GAAMA,EAAI,KAC9B,EACM8F,GAA0B,CAC5B,UAAW,CACP,OAAQ,sBACR,aAAc,MACd,cAAgB9F,GAAMA,EAAI,IAC7B,EACD,OAAQ6F,EACR,MAAO,CACH,OAAQ,WACR,aAAc,EACd,cAAehF,CAClB,EACD,KAAMgF,CACV,EACME,EAAuB,IAAI,IAC3BC,EAAqBP,GAAS,YAAYA,CAAI,GAI9CQ,EAAa,CAAC,IAAK,IAAK,GAAG,EACjCN,GAAM,QAASF,GAAS,CACpBC,GAAK,QAASQ,GAAS,CACnBD,EAAW,KAAKR,EAAOS,CAAI,EAC3BH,EAAqB,IAAIC,EAAkBP,EAAOS,CAAI,EAAGJ,GAAwBL,CAAI,CAAC,CAC9F,CAAK,CACL,CAAC,EAID,MAAMU,GAAwB,CAACC,EAAGC,IAAMJ,EAAW,QAAQG,CAAC,EAAIH,EAAW,QAAQI,CAAC,EAI9EC,GAAkB,IAAI,IAAIL,CAAU,EACpCM,GAAed,GAASa,GAAgB,IAAIb,CAAI,EAChDe,GAAwB,CAAClB,EAASG,IAAS,CAEzCG,EAAeH,CAAI,IACnBA,EAAOG,EAAeH,CAAI,GAC9B,KAAM,CAAE,WAAAQ,CAAU,EAAKZ,GAAiBC,CAAO,EAC/C5F,GAAcuG,EAAYR,CAAI,EAK9BH,EAAQ,MAAM,UAAYmB,GAAuBR,CAAU,CAC/D,EACMQ,GAA0BR,GAAeA,EAC1C,KAAKE,EAAqB,EAC1B,OAAOO,GAAuB,EAAE,EAChC,OACCA,GAAwB,CAACC,EAAUlB,IAAS,GAAGkB,CAAQ,IAAIlB,CAAI,QAAQO,EAAkBP,CAAI,CAAC,KCxE9FmB,EAAYnB,GAASA,EAAK,WAAW,IAAI,EACzCoB,EAAuB,IAAI,IACjC,SAASC,GAAoBrB,EAAM,CAC/B,GAAI,CAAAoB,EAAqB,IAAIpB,CAAI,EAEjC,CAAAoB,EAAqB,IAAIpB,CAAI,EAC7B,GAAI,CACA,KAAM,CAAE,OAAAsB,EAAQ,aAAAC,CAAY,EAAKjB,EAAqB,IAAIN,CAAI,EACxDM,EAAqB,IAAIN,CAAI,EAC7B,GACN,IAAI,iBAAiB,CACjB,KAAAA,EACA,SAAU,GACV,OAAAsB,EACA,aAAAC,CACZ,CAAS,CACJ,MACS,CAAG,EACjB,CCpBA,MAAMC,EAAgB,CAACnD,EAAWoD,IAAY,SAAS,cAAc,KAAK,EAAE,QAAQpD,EAAWoD,CAAO,EAChGC,GAAe,CACjB,oBAAqB,IAAM,OAAO,IAAQ,KACtC,OAAO,eAAe,KAAK,IAAK,kBAAkB,EACtD,MAAO,IAAM,OAAO,eAAe,KAAK,QAAQ,UAAW,SAAS,EACpE,iBAAkB,IAAM,CACpB,GAAI,CACAF,EAAc,CAAE,QAAS,CAAC,CAAC,CAAG,CAAA,CACjC,MACS,CACN,MAAO,EACV,CACD,MAAO,EACV,EACD,SAAU,IAAM,EAAQA,EAAc,CAAE,QAAS,CAAC,EAAG,CAAC,CAAG,EAAE,CAAE,SAAU,IAAO,CAAA,EAAE,SAChF,aAAc,IAAM,CAChB,GAAI,CACAA,EAAc,CAAE,QAAS,CAAC,EAAI,CAAE,OAAQ,cAAc,CAAE,CAC3D,MACS,CACN,MAAO,EACV,CACD,MAAO,EACV,CACL,EACMG,EAAU,CAAA,EACVC,EAAW,CAAA,EACjB,UAAWC,KAAOH,GACdE,EAASC,CAAG,EAAI,KACRF,EAAQE,CAAG,IAAM,SACjBF,EAAQE,CAAG,EAAIH,GAAaG,CAAG,EAAC,GAC7BF,EAAQE,CAAG,GC3B1B,MAAMC,GAAa,KACbC,GAA6B,CAACnH,EAAQ2E,IAAa,CACrD,IAAIyC,EAAS,GACb,MAAMC,EAAY,KAAK,MAAM1C,EAAWuC,EAAU,EAClD,QAAS9G,EAAI,EAAGA,EAAIiH,EAAWjH,IAC3BgH,GAAUpH,EAAOM,EAAS,EAAG+G,EAAY,EAAGjH,CAAC,CAAC,EAAI,KAEtD,OAAOgH,EAAO,UAAU,EAAGA,EAAO,OAAS,CAAC,CAChD,EACME,GAAgB,CAACtH,EAAQ2E,IACvBpD,EAAWvB,CAAM,EACVgH,EAAS,aAAc,EACxB,UAAUG,GAA2BnH,EAAQ2E,CAAQ,CAAC,IACtD/E,EAAS,OAGRyB,GAAcrB,CAAM,EAAIuH,GAAoBvH,CAAM,EAAIA,EAG/DuH,GAAsB,CAAC,CAACxB,EAAGC,EAAGwB,EAAGC,CAAC,IAAM,gBAAgB1B,CAAC,KAAKC,CAAC,KAAKwB,CAAC,KAAKC,CAAC,ICvBjF,SAASC,GAAiBjE,EAAWkE,EAAkB,CACnD,QAAS,EAAI,EAAG,EAAIlE,EAAU,OAAQ,IAC9BA,EAAU,CAAC,IAAM,OACjBA,EAAU,CAAC,EAAI,EAAIA,EAAU,EAAI,CAAC,EAAIkE,KAG9C,OAAOlE,CACX,CACA,MAAMmE,GAAiBnE,GAAc,MAAM,QAAQA,CAAS,EAAIA,EAAY,CAACA,CAAS,ECNtF,SAASoE,EAAaZ,EAAK,CACvB,OAAI1B,EAAe0B,CAAG,IAClBA,EAAM1B,EAAe0B,CAAG,GACrBf,GAAYe,CAAG,EAAItB,EAAkBsB,CAAG,EAAIA,CACvD,CCFA,MAAMa,EAAQ,CACV,IAAK,CAAC7C,EAASG,IAAS,CACpBA,EAAOyC,EAAazC,CAAI,EACxB,IAAItF,EAAQyG,EAASnB,CAAI,EACnBH,EAAQ,MAAM,iBAAiBG,CAAI,EACnC,iBAAiBH,CAAO,EAAEG,CAAI,EACpC,GAAI,CAACtF,GAASA,IAAU,EAAG,CACvB,MAAMuD,EAAaqC,EAAqB,IAAIN,CAAI,EAC5C/B,IACAvD,EAAQuD,EAAW,aAC1B,CACD,OAAOvD,CACV,EACD,IAAK,CAACmF,EAASG,EAAMtF,IAAU,CAC3BsF,EAAOyC,EAAazC,CAAI,EACpBmB,EAASnB,CAAI,EACbH,EAAQ,MAAM,YAAYG,EAAMtF,CAAK,EAGrCmF,EAAQ,MAAMG,CAAI,EAAItF,CAE7B,CACL,EC1BA,SAASiI,GAAcjD,EAAWkD,EAAc,GAAM,CAClD,GAAI,GAAClD,GAAaA,EAAU,YAAc,YAG1C,GAAI,CACIA,EAAU,KACVA,EAAU,KAAI,GAGdkD,GAAelD,EAAU,eACzBA,EAAU,OAAM,EAEvB,MACS,CAAG,CACjB,CCZA,SAASmD,GAAiBxE,EAAWJ,EAAY,CAC7C,IAAIe,EACJ,IAAI8D,GAAU7E,GAAe,KAAgC,OAASA,EAAW,gBAAkB7C,EACnG,MAAM2H,EAAgB1E,EAAUA,EAAU,OAAS,CAAC,EACpD,GAAIjC,GAAS2G,CAAa,EAAG,CACzB,MAAMC,IAAShE,EAAK+D,EAAc,MAAM,qBAAqB,KAAO,MAAQ/D,IAAO,OAAS,OAASA,EAAG,CAAC,IAAM,GAC3GgE,IACAF,EAAUpI,GAAUA,EAAQsI,EACnC,CACD,OAAOF,CACX,CCAA,SAASG,IAAoB,CACzB,OAAO,OAAO,yBAClB,CACA,SAASC,GAAarD,EAASgC,EAAKsB,EAAqB1B,EAAU,CAAE,EAAE2B,EAAmB,CACtF,MAAMC,EAASJ,KACTK,EAAc7B,EAAQ,SAAW,IAAS4B,EAChD,IAAI3D,EACA,CAAE,SAAAH,EAAW/E,EAAS,SAAU,MAAA+D,EAAQ/D,EAAS,MAAO,SAAAgE,EAAWhE,EAAS,SAAU,OAAAiE,EAASjE,EAAS,OAAQ,OAAAI,EAASJ,EAAS,OAAQ,QAAA+I,EAAU,GAAO,UAAA5F,EAAW,OAAArC,EAAQ,wBAAAkI,EAA0B,GAAO,SAAA9E,EAAW,EAAI,EAAM+C,EACxO,MAAM9B,EAAOC,GAAiBC,CAAO,EAC/B4D,EAAmB3C,GAAYe,CAAG,EACxC,IAAI6B,EAAqB9B,EAAS,QAKlC6B,GAAoB1C,GAAsBlB,EAASgC,CAAG,EACtD,MAAM7B,EAAOyC,EAAaZ,CAAG,EACvB8B,EAAc7D,GAAeH,EAAK,OAAQK,CAAI,EAK9C/B,EAAaqC,EAAqB,IAAIN,CAAI,EAOhD,OAAA2C,GAAcgB,EAAY,UAAW,EAAEzH,EAAkBtB,CAAM,GAAK+I,EAAY,YAC5ElC,EAAQ,SAAW,EAAK,EAIrB,IAAM,CACT,MAAMc,EAAmB,IAAM,CAAE,IAAIvD,EAAI4E,EAAI,OAAQA,GAAM5E,EAAK0D,EAAM,IAAI7C,EAASG,CAAI,KAAO,MAAQhB,IAAO,OAASA,EAAKf,GAAe,KAAgC,OAASA,EAAW,gBAAkB,MAAQ2F,IAAO,OAASA,EAAK,GAK7O,IAAIvF,EAAYiE,GAAiBE,GAAcW,CAAmB,EAAGZ,CAAgB,EAIrF,MAAMO,EAASD,GAAiBxE,EAAWJ,CAAU,EACrD,GAAI/B,EAAkBtB,CAAM,EAAG,CAC3B,MAAMiE,EAASjE,EAAO,gBAAgByD,EAAWwD,IAAQ,UAAWU,EAAkBvC,EAAM2D,CAAW,EACvG/I,EAASiE,EAAO,OAChBR,EAAYQ,EAAO,WAAaR,EAChCkB,EAAWV,EAAO,UAAYU,CACjC,CA4BD,GAtBI4B,EAASnB,CAAI,IACT4B,EAAS,sBACTP,GAAoBrB,CAAI,EAGxB0D,EAAqB,IASzBD,GACA,CAAC7B,EAAS,aAAc,IACvBzF,EAAWvB,CAAM,GAAMD,EAAaC,CAAM,GAAKA,EAAO,KAAKuB,CAAU,KACtEuH,EAAqB,IAKrBA,EAAoB,CAKhBzF,IACAI,EAAYA,EAAU,IAAK3D,GAAUD,EAASC,CAAK,EAAIuD,EAAW,cAAcvD,CAAK,EAAIA,CAAK,GAM9F2D,EAAU,SAAW,IACpB,CAACuD,EAAS,oBAAsB0B,IACjCjF,EAAU,QAAQkE,EAAgB,CAAE,EAExC,MAAMsB,EAAmB,CACrB,MAAOxH,EAAK,GAAGkC,CAAK,EACpB,SAAUlC,EAAK,GAAGkD,CAAQ,EAC1B,SAAUlD,EAAK,GAAGmC,CAAQ,EAC1B,OAAS7D,EAAaC,CAAM,EAEtB,OADAsH,GAActH,EAAQ2E,CAAQ,EAEpC,UAAA5B,EACA,WAAYc,EAAS,EACrB,KAAM,MACtB,EACYiB,EAAYG,EAAQ,QAAQ,CACxB,CAACG,CAAI,EAAG3B,EACR,OAAA/C,EACA,OAAQX,EAAaC,CAAM,EACrBA,EAAO,IAAKkJ,GAAe5B,GAAc4B,EAAYvE,CAAQ,CAAC,EAC9D,MACT,EAAEsE,CAAgB,EAIdnE,EAAU,WACXA,EAAU,SAAW,IAAI,QAAQ,CAACf,EAASC,KAAW,CAClDc,EAAU,SAAWf,EACrBe,EAAU,SAAWd,EACzC,CAAiB,GAEL,MAAMmF,EAAS1F,EAAUA,EAAU,OAAS,CAAC,EAC7CqB,EAAU,SACL,KAAK,IAAM,CACR6D,IAGJb,EAAM,IAAI7C,EAASG,EAAM+D,CAAM,EAE/BrE,EAAU,OAAM,EAChC,CAAa,EACI,MAAMvE,EAAI,EAUVqI,IACD9D,EAAU,aAAe,SAKhC,SACQ0D,GAAqBK,EAK1BpF,EAAYA,EAAU,IAAK3D,GAAU,OAAOA,GAAU,SAAW,WAAWA,CAAK,EAAIA,CAAK,EAKtF2D,EAAU,SAAW,GACrBA,EAAU,QAAQ,WAAWkE,EAAgB,CAAE,CAAC,EAEpD7C,EAAY,IAAI0D,EAAmB/D,GAAW,CAC1CqD,EAAM,IAAI7C,EAASG,EAAM8C,EAASA,EAAOzD,CAAM,EAAIA,CAAM,CACzE,EAAehB,EAAW,OAAO,OAAO,OAAO,OAAO,CAAE,EAAEoD,CAAO,EAAG,CAAE,SAAAlC,EACtD,OAAA3E,CAAM,CAAE,CAAC,MAEZ,CACD,MAAMmJ,EAAS1F,EAAUA,EAAU,OAAS,CAAC,EAC7CqE,EAAM,IAAI7C,EAASG,EAAM/B,GAAcxD,EAASsJ,CAAM,EAChD9F,EAAW,cAAc8F,CAAM,EAC/BA,CAAM,CACf,CACD,OAAIT,GACAD,EAAOxD,EAASgC,EAAKxD,EAAW,CAC5B,SAAAkB,EACA,MAAOhB,EACP,OAAA3D,EACA,OAAA6D,EACA,OAAAnD,CACH,EAAE,YAAY,EAEnBqI,EAAY,aAAajE,CAAS,EAC9BA,GAAa,CAAChB,GACdgB,EAAU,MAAK,EACZA,CACf,CACA,CCtMA,MAAMsE,GAAa,CAACvC,EAASI,IAM7BJ,EAAQI,CAAG,EAAI,OAAO,OAAO,OAAO,OAAO,GAAIJ,CAAO,EAAGA,EAAQI,CAAG,CAAC,EAAI,OAAO,OAAO,CAAE,EAAEJ,CAAO,ECNlG,SAASwC,GAAgBC,EAAUC,EAAe,CAE9C,OAAI,OAAOD,GAAa,SAMhBA,EAAW,SAAS,iBAAiBA,CAAQ,EAG5CA,aAAoB,UACzBA,EAAW,CAACA,CAAQ,GAKjB,MAAM,KAAKA,GAAY,CAAE,CAAA,CACpC,CCfA,MAAME,GAAmBC,GAAYA,IAC/BC,GAAe,CAACC,EAAkB9C,EAASlC,EAAW/E,EAAS,WAC1D,IAAI,MAAM,CACb,WAAY+J,EAAiB,IAAIH,EAAe,EAAE,OAAO,OAAO,EAChE,SAAA7E,EACA,QAAAkC,CACH,EAAE+C,EAAQ,EAOTC,GAAsBC,GAAUA,EAAM,WAAW,CAAC,EAClDF,GAAW,CACb,IAAK,CAACT,EAAQlC,IAAQ,CAClB,MAAM8C,EAAkBF,GAAmBV,CAAM,EACjD,OAAQlC,EAAG,CACP,IAAK,WACD,OAAOkC,EAAO,SAClB,IAAK,cACD,OAAO1H,EAAK,GAAGsI,GAAoB,KAAqC,OAASA,EAAgB9C,CAAG,IAAM,CAAC,EAC/G,IAAK,eACL,IAAK,YACD,OAAO8C,GAAoB,KAAqC,OAASA,EAAgB9C,CAAG,EAChG,IAAK,WACD,OAAKkC,EAAO,WACRA,EAAO,SAAW,QAAQ,IAAIA,EAAO,WAAW,IAAIa,EAAc,CAAC,EAAE,MAAMzJ,EAAI,GAE5E4I,EAAO,SAClB,IAAK,OACD,MAAO,IAAM,CACTA,EAAO,WAAW,QAASrE,GAAciD,GAAcjD,CAAS,CAAC,CACrF,EACY,IAAK,gBAKD,OAAQmF,GAAa,CACjBd,EAAO,WAAW,QAASrE,GAAcmF,EAASnF,EAAWqE,CAAM,CAAC,CACxF,EACY,QACI,OAAO,OAAQY,GAAoB,KAAqC,OAASA,EAAgB9C,CAAG,GAAO,IACrG,OACA,IAAMkC,EAAO,WAAW,QAASrE,GAAcA,EAAUmC,CAAG,EAAC,CAAE,CAC5E,CACJ,EACD,IAAK,CAACkC,EAAQlC,EAAKnH,IAAU,CACzB,OAAQmH,EAAG,CACP,IAAK,cACDnH,EAAQ2B,EAAK,GAAG3B,CAAK,EAEzB,IAAK,eACD,QAASM,EAAI,EAAGA,EAAI+I,EAAO,WAAW,OAAQ/I,IAC1C+I,EAAO,WAAW/I,CAAC,EAAE6G,CAAG,EAAInH,EAEhC,MAAO,EACd,CACD,MAAO,EACV,CACL,EACMkK,GAAkBlF,GAAcA,EAAU,SCxChD,SAASoF,GAAcC,EAAQ/J,EAAGgK,EAAO,CACrC,OAAO7I,EAAW4I,CAAM,EAAIA,EAAO/J,EAAGgK,CAAK,EAAID,CACnD,CCpBA,SAASE,GAAcC,EAAiB,CACpC,OAAO,SAAiBhB,EAAU7F,EAAWoD,EAAU,CAAA,EAAI,CACvDyC,EAAWD,GAAgBC,CAAQ,EACnC,MAAMiB,EAAcjB,EAAS,OAMvBkB,EAAqB,CAAA,EAC3B,QAASpK,EAAI,EAAGA,EAAImK,EAAanK,IAAK,CAClC,MAAM6E,EAAUqE,EAASlJ,CAAC,EAC1B,UAAW6G,KAAOxD,EAAW,CACzB,MAAMgH,EAAerB,GAAWvC,EAASI,CAAG,EAC5CwD,EAAa,MAAQP,GAAcO,EAAa,MAAOrK,EAAGmK,CAAW,EACrE,MAAMzF,EAAYwD,GAAarD,EAASgC,EAAKxD,EAAUwD,CAAG,EAAGwD,EAAcH,CAAe,EAC1FE,EAAmB,KAAK1F,CAAS,CACpC,CACJ,CACD,OAAO4E,GAAac,EAAoB3D,EAUxCA,EAAQ,QAAQ,CACxB,CACA,CCnCK,MAAC6D,GAAUL,GAAc7G,EAAS","x_google_ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38]}