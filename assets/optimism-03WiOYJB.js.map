{"version":3,"file":"optimism-03WiOYJB.js","sources":["../../node_modules/optimism/node_modules/@wry/trie/lib/index.js","../../node_modules/optimism/lib/context.js","../../node_modules/optimism/lib/helpers.js","../../node_modules/optimism/lib/entry.js","../../node_modules/optimism/lib/dep.js","../../node_modules/optimism/lib/index.js"],"sourcesContent":["// A [trie](https://en.wikipedia.org/wiki/Trie) data structure that holds\n// object keys weakly, yet can also hold non-object keys, unlike the\n// native `WeakMap`.\n// If no makeData function is supplied, the looked-up data will be an empty,\n// null-prototype Object.\nconst defaultMakeData = () => Object.create(null);\n// Useful for processing arguments objects as well as arrays.\nconst { forEach, slice } = Array.prototype;\nconst { hasOwnProperty } = Object.prototype;\nexport class Trie {\n    constructor(weakness = true, makeData = defaultMakeData) {\n        this.weakness = weakness;\n        this.makeData = makeData;\n    }\n    lookup(...array) {\n        return this.lookupArray(array);\n    }\n    lookupArray(array) {\n        let node = this;\n        forEach.call(array, key => node = node.getChildTrie(key));\n        return hasOwnProperty.call(node, \"data\")\n            ? node.data\n            : node.data = this.makeData(slice.call(array));\n    }\n    peek(...array) {\n        return this.peekArray(array);\n    }\n    peekArray(array) {\n        let node = this;\n        for (let i = 0, len = array.length; node && i < len; ++i) {\n            const map = this.weakness && isObjRef(array[i]) ? node.weak : node.strong;\n            node = map && map.get(array[i]);\n        }\n        return node && node.data;\n    }\n    getChildTrie(key) {\n        const map = this.weakness && isObjRef(key)\n            ? this.weak || (this.weak = new WeakMap())\n            : this.strong || (this.strong = new Map());\n        let child = map.get(key);\n        if (!child)\n            map.set(key, child = new Trie(this.weakness, this.makeData));\n        return child;\n    }\n}\nfunction isObjRef(value) {\n    switch (typeof value) {\n        case \"object\":\n            if (value === null)\n                break;\n        // Fall through to return true...\n        case \"function\":\n            return true;\n    }\n    return false;\n}\n//# sourceMappingURL=index.js.map","import { Slot } from \"@wry/context\";\nexport const parentEntrySlot = new Slot();\nexport function nonReactive(fn) {\n    return parentEntrySlot.withValue(void 0, fn);\n}\nexport { Slot };\nexport { bind as bindContext, noContext, setTimeout, asyncFromGen, } from \"@wry/context\";\n//# sourceMappingURL=context.js.map","export const { hasOwnProperty, } = Object.prototype;\nexport const arrayFromSet = Array.from ||\n    function (set) {\n        const array = [];\n        set.forEach(item => array.push(item));\n        return array;\n    };\nexport function maybeUnsubscribe(entryOrDep) {\n    const { unsubscribe } = entryOrDep;\n    if (typeof unsubscribe === \"function\") {\n        entryOrDep.unsubscribe = void 0;\n        unsubscribe();\n    }\n}\n//# sourceMappingURL=helpers.js.map","import { parentEntrySlot } from \"./context.js\";\nimport { maybeUnsubscribe, arrayFromSet } from \"./helpers.js\";\nconst emptySetPool = [];\nconst POOL_TARGET_SIZE = 100;\n// Since this package might be used browsers, we should avoid using the\n// Node built-in assert module.\nfunction assert(condition, optionalMessage) {\n    if (!condition) {\n        throw new Error(optionalMessage || \"assertion failure\");\n    }\n}\nfunction valueIs(a, b) {\n    const len = a.length;\n    return (\n    // Unknown values are not equal to each other.\n    len > 0 &&\n        // Both values must be ordinary (or both exceptional) to be equal.\n        len === b.length &&\n        // The underlying value or exception must be the same.\n        a[len - 1] === b[len - 1]);\n}\nfunction valueGet(value) {\n    switch (value.length) {\n        case 0: throw new Error(\"unknown value\");\n        case 1: return value[0];\n        case 2: throw value[1];\n    }\n}\nfunction valueCopy(value) {\n    return value.slice(0);\n}\nexport class Entry {\n    constructor(fn) {\n        this.fn = fn;\n        this.parents = new Set();\n        this.childValues = new Map();\n        // When this Entry has children that are dirty, this property becomes\n        // a Set containing other Entry objects, borrowed from emptySetPool.\n        // When the set becomes empty, it gets recycled back to emptySetPool.\n        this.dirtyChildren = null;\n        this.dirty = true;\n        this.recomputing = false;\n        this.value = [];\n        this.deps = null;\n        ++Entry.count;\n    }\n    peek() {\n        if (this.value.length === 1 && !mightBeDirty(this)) {\n            rememberParent(this);\n            return this.value[0];\n        }\n    }\n    // This is the most important method of the Entry API, because it\n    // determines whether the cached this.value can be returned immediately,\n    // or must be recomputed. The overall performance of the caching system\n    // depends on the truth of the following observations: (1) this.dirty is\n    // usually false, (2) this.dirtyChildren is usually null/empty, and thus\n    // (3) valueGet(this.value) is usually returned without recomputation.\n    recompute(args) {\n        assert(!this.recomputing, \"already recomputing\");\n        rememberParent(this);\n        return mightBeDirty(this)\n            ? reallyRecompute(this, args)\n            : valueGet(this.value);\n    }\n    setDirty() {\n        if (this.dirty)\n            return;\n        this.dirty = true;\n        reportDirty(this);\n        // We can go ahead and unsubscribe here, since any further dirty\n        // notifications we receive will be redundant, and unsubscribing may\n        // free up some resources, e.g. file watchers.\n        maybeUnsubscribe(this);\n    }\n    dispose() {\n        this.setDirty();\n        // Sever any dependency relationships with our own children, so those\n        // children don't retain this parent Entry in their child.parents sets,\n        // thereby preventing it from being fully garbage collected.\n        forgetChildren(this);\n        // Because this entry has been kicked out of the cache (in index.js),\n        // we've lost the ability to find out if/when this entry becomes dirty,\n        // whether that happens through a subscription, because of a direct call\n        // to entry.setDirty(), or because one of its children becomes dirty.\n        // Because of this loss of future information, we have to assume the\n        // worst (that this entry might have become dirty very soon), so we must\n        // immediately mark this entry's parents as dirty. Normally we could\n        // just call entry.setDirty() rather than calling parent.setDirty() for\n        // each parent, but that would leave this entry in parent.childValues\n        // and parent.dirtyChildren, which would prevent the child from being\n        // truly forgotten.\n        eachParent(this, (parent, child) => {\n            parent.setDirty();\n            forgetChild(parent, this);\n        });\n    }\n    forget() {\n        // The code that creates Entry objects in index.ts will replace this method\n        // with one that actually removes the Entry from the cache, which will also\n        // trigger the entry.dispose method.\n        this.dispose();\n    }\n    dependOn(dep) {\n        dep.add(this);\n        if (!this.deps) {\n            this.deps = emptySetPool.pop() || new Set();\n        }\n        this.deps.add(dep);\n    }\n    forgetDeps() {\n        if (this.deps) {\n            arrayFromSet(this.deps).forEach(dep => dep.delete(this));\n            this.deps.clear();\n            emptySetPool.push(this.deps);\n            this.deps = null;\n        }\n    }\n}\nEntry.count = 0;\nfunction rememberParent(child) {\n    const parent = parentEntrySlot.getValue();\n    if (parent) {\n        child.parents.add(parent);\n        if (!parent.childValues.has(child)) {\n            parent.childValues.set(child, []);\n        }\n        if (mightBeDirty(child)) {\n            reportDirtyChild(parent, child);\n        }\n        else {\n            reportCleanChild(parent, child);\n        }\n        return parent;\n    }\n}\nfunction reallyRecompute(entry, args) {\n    forgetChildren(entry);\n    // Set entry as the parent entry while calling recomputeNewValue(entry).\n    parentEntrySlot.withValue(entry, recomputeNewValue, [entry, args]);\n    if (maybeSubscribe(entry, args)) {\n        // If we successfully recomputed entry.value and did not fail to\n        // (re)subscribe, then this Entry is no longer explicitly dirty.\n        setClean(entry);\n    }\n    return valueGet(entry.value);\n}\nfunction recomputeNewValue(entry, args) {\n    entry.recomputing = true;\n    const { normalizeResult } = entry;\n    let oldValueCopy;\n    if (normalizeResult && entry.value.length === 1) {\n        oldValueCopy = valueCopy(entry.value);\n    }\n    // Make entry.value an empty array, representing an unknown value.\n    entry.value.length = 0;\n    try {\n        // If entry.fn succeeds, entry.value will become a normal Value.\n        entry.value[0] = entry.fn.apply(null, args);\n        // If we have a viable oldValueCopy to compare with the (successfully\n        // recomputed) new entry.value, and they are not already === identical, give\n        // normalizeResult a chance to pick/choose/reuse parts of oldValueCopy[0]\n        // and/or entry.value[0] to determine the final cached entry.value.\n        if (normalizeResult && oldValueCopy && !valueIs(oldValueCopy, entry.value)) {\n            try {\n                entry.value[0] = normalizeResult(entry.value[0], oldValueCopy[0]);\n            }\n            catch (_a) {\n                // If normalizeResult throws, just use the newer value, rather than\n                // saving the exception as entry.value[1].\n            }\n        }\n    }\n    catch (e) {\n        // If entry.fn throws, entry.value will hold that exception.\n        entry.value[1] = e;\n    }\n    // Either way, this line is always reached.\n    entry.recomputing = false;\n}\nfunction mightBeDirty(entry) {\n    return entry.dirty || !!(entry.dirtyChildren && entry.dirtyChildren.size);\n}\nfunction setClean(entry) {\n    entry.dirty = false;\n    if (mightBeDirty(entry)) {\n        // This Entry may still have dirty children, in which case we can't\n        // let our parents know we're clean just yet.\n        return;\n    }\n    reportClean(entry);\n}\nfunction reportDirty(child) {\n    eachParent(child, reportDirtyChild);\n}\nfunction reportClean(child) {\n    eachParent(child, reportCleanChild);\n}\nfunction eachParent(child, callback) {\n    const parentCount = child.parents.size;\n    if (parentCount) {\n        const parents = arrayFromSet(child.parents);\n        for (let i = 0; i < parentCount; ++i) {\n            callback(parents[i], child);\n        }\n    }\n}\n// Let a parent Entry know that one of its children may be dirty.\nfunction reportDirtyChild(parent, child) {\n    // Must have called rememberParent(child) before calling\n    // reportDirtyChild(parent, child).\n    assert(parent.childValues.has(child));\n    assert(mightBeDirty(child));\n    const parentWasClean = !mightBeDirty(parent);\n    if (!parent.dirtyChildren) {\n        parent.dirtyChildren = emptySetPool.pop() || new Set;\n    }\n    else if (parent.dirtyChildren.has(child)) {\n        // If we already know this child is dirty, then we must have already\n        // informed our own parents that we are dirty, so we can terminate\n        // the recursion early.\n        return;\n    }\n    parent.dirtyChildren.add(child);\n    // If parent was clean before, it just became (possibly) dirty (according to\n    // mightBeDirty), since we just added child to parent.dirtyChildren.\n    if (parentWasClean) {\n        reportDirty(parent);\n    }\n}\n// Let a parent Entry know that one of its children is no longer dirty.\nfunction reportCleanChild(parent, child) {\n    // Must have called rememberChild(child) before calling\n    // reportCleanChild(parent, child).\n    assert(parent.childValues.has(child));\n    assert(!mightBeDirty(child));\n    const childValue = parent.childValues.get(child);\n    if (childValue.length === 0) {\n        parent.childValues.set(child, valueCopy(child.value));\n    }\n    else if (!valueIs(childValue, child.value)) {\n        parent.setDirty();\n    }\n    removeDirtyChild(parent, child);\n    if (mightBeDirty(parent)) {\n        return;\n    }\n    reportClean(parent);\n}\nfunction removeDirtyChild(parent, child) {\n    const dc = parent.dirtyChildren;\n    if (dc) {\n        dc.delete(child);\n        if (dc.size === 0) {\n            if (emptySetPool.length < POOL_TARGET_SIZE) {\n                emptySetPool.push(dc);\n            }\n            parent.dirtyChildren = null;\n        }\n    }\n}\n// Removes all children from this entry and returns an array of the\n// removed children.\nfunction forgetChildren(parent) {\n    if (parent.childValues.size > 0) {\n        parent.childValues.forEach((_value, child) => {\n            forgetChild(parent, child);\n        });\n    }\n    // Remove this parent Entry from any sets to which it was added by the\n    // addToSet method.\n    parent.forgetDeps();\n    // After we forget all our children, this.dirtyChildren must be empty\n    // and therefore must have been reset to null.\n    assert(parent.dirtyChildren === null);\n}\nfunction forgetChild(parent, child) {\n    child.parents.delete(parent);\n    parent.childValues.delete(child);\n    removeDirtyChild(parent, child);\n}\nfunction maybeSubscribe(entry, args) {\n    if (typeof entry.subscribe === \"function\") {\n        try {\n            maybeUnsubscribe(entry); // Prevent double subscriptions.\n            entry.unsubscribe = entry.subscribe.apply(null, args);\n        }\n        catch (e) {\n            // If this Entry has a subscribe function and it threw an exception\n            // (or an unsubscribe function it previously returned now throws),\n            // return false to indicate that we were not able to subscribe (or\n            // unsubscribe), and this Entry should remain dirty.\n            entry.setDirty();\n            return false;\n        }\n    }\n    // Returning true indicates either that there was no entry.subscribe\n    // function or that it succeeded.\n    return true;\n}\n//# sourceMappingURL=entry.js.map","import { parentEntrySlot } from \"./context.js\";\nimport { hasOwnProperty, maybeUnsubscribe, arrayFromSet, } from \"./helpers.js\";\nconst EntryMethods = {\n    setDirty: true,\n    dispose: true,\n    forget: true, // Fully remove parent Entry from LRU cache and computation graph\n};\nexport function dep(options) {\n    const depsByKey = new Map();\n    const subscribe = options && options.subscribe;\n    function depend(key) {\n        const parent = parentEntrySlot.getValue();\n        if (parent) {\n            let dep = depsByKey.get(key);\n            if (!dep) {\n                depsByKey.set(key, dep = new Set);\n            }\n            parent.dependOn(dep);\n            if (typeof subscribe === \"function\") {\n                maybeUnsubscribe(dep);\n                dep.unsubscribe = subscribe(key);\n            }\n        }\n    }\n    depend.dirty = function dirty(key, entryMethodName) {\n        const dep = depsByKey.get(key);\n        if (dep) {\n            const m = (entryMethodName &&\n                hasOwnProperty.call(EntryMethods, entryMethodName)) ? entryMethodName : \"setDirty\";\n            // We have to use arrayFromSet(dep).forEach instead of dep.forEach,\n            // because modifying a Set while iterating over it can cause elements in\n            // the Set to be removed from the Set before they've been iterated over.\n            arrayFromSet(dep).forEach(entry => entry[m]());\n            depsByKey.delete(key);\n            maybeUnsubscribe(dep);\n        }\n    };\n    return depend;\n}\n//# sourceMappingURL=dep.js.map","import { Trie } from \"@wry/trie\";\nimport { StrongCache } from \"@wry/caches\";\nimport { Entry } from \"./entry.js\";\nimport { parentEntrySlot } from \"./context.js\";\n// These helper functions are important for making optimism work with\n// asynchronous code. In order to register parent-child dependencies,\n// optimism needs to know about any currently active parent computations.\n// In ordinary synchronous code, the parent context is implicit in the\n// execution stack, but asynchronous code requires some extra guidance in\n// order to propagate context from one async task segment to the next.\nexport { bindContext, noContext, nonReactive, setTimeout, asyncFromGen, Slot, } from \"./context.js\";\n// A lighter-weight dependency, similar to OptimisticWrapperFunction, except\n// with only one argument, no makeCacheKey, no wrapped function to recompute,\n// and no result value. Useful for representing dependency leaves in the graph\n// of computation. Subscriptions are supported.\nexport { dep } from \"./dep.js\";\n// The defaultMakeCacheKey function is remarkably powerful, because it gives\n// a unique object for any shallow-identical list of arguments. If you need\n// to implement a custom makeCacheKey function, you may find it helpful to\n// delegate the final work to defaultMakeCacheKey, which is why we export it\n// here. However, you may want to avoid defaultMakeCacheKey if your runtime\n// does not support WeakMap, or you have the ability to return a string key.\n// In those cases, just write your own custom makeCacheKey functions.\nlet defaultKeyTrie;\nexport function defaultMakeCacheKey(...args) {\n    const trie = defaultKeyTrie || (defaultKeyTrie = new Trie(typeof WeakMap === \"function\"));\n    return trie.lookupArray(args);\n}\n// If you're paranoid about memory leaks, or you want to avoid using WeakMap\n// under the hood, but you still need the behavior of defaultMakeCacheKey,\n// import this constructor to create your own tries.\nexport { Trie as KeyTrie };\n;\nconst caches = new Set();\nexport function wrap(originalFunction, { max = Math.pow(2, 16), keyArgs, makeCacheKey = defaultMakeCacheKey, normalizeResult, subscribe, cache: cacheOption = StrongCache, } = Object.create(null)) {\n    const cache = typeof cacheOption === \"function\"\n        ? new cacheOption(max, entry => entry.dispose())\n        : cacheOption;\n    const optimistic = function () {\n        const key = makeCacheKey.apply(null, keyArgs ? keyArgs.apply(null, arguments) : arguments);\n        if (key === void 0) {\n            return originalFunction.apply(null, arguments);\n        }\n        let entry = cache.get(key);\n        if (!entry) {\n            cache.set(key, entry = new Entry(originalFunction));\n            entry.normalizeResult = normalizeResult;\n            entry.subscribe = subscribe;\n            // Give the Entry the ability to trigger cache.delete(key), even though\n            // the Entry itself does not know about key or cache.\n            entry.forget = () => cache.delete(key);\n        }\n        const value = entry.recompute(Array.prototype.slice.call(arguments));\n        // Move this entry to the front of the least-recently used queue,\n        // since we just finished computing its value.\n        cache.set(key, entry);\n        caches.add(cache);\n        // Clean up any excess entries in the cache, but only if there is no\n        // active parent entry, meaning we're not in the middle of a larger\n        // computation that might be flummoxed by the cleaning.\n        if (!parentEntrySlot.hasValue()) {\n            caches.forEach(cache => cache.clean());\n            caches.clear();\n        }\n        return value;\n    };\n    Object.defineProperty(optimistic, \"size\", {\n        get: () => cache.size,\n        configurable: false,\n        enumerable: false,\n    });\n    Object.freeze(optimistic.options = {\n        max,\n        keyArgs,\n        makeCacheKey,\n        normalizeResult,\n        subscribe,\n        cache,\n    });\n    function dirtyKey(key) {\n        const entry = key && cache.get(key);\n        if (entry) {\n            entry.setDirty();\n        }\n    }\n    optimistic.dirtyKey = dirtyKey;\n    optimistic.dirty = function dirty() {\n        dirtyKey(makeCacheKey.apply(null, arguments));\n    };\n    function peekKey(key) {\n        const entry = key && cache.get(key);\n        if (entry) {\n            return entry.peek();\n        }\n    }\n    optimistic.peekKey = peekKey;\n    optimistic.peek = function peek() {\n        return peekKey(makeCacheKey.apply(null, arguments));\n    };\n    function forgetKey(key) {\n        return key ? cache.delete(key) : false;\n    }\n    optimistic.forgetKey = forgetKey;\n    optimistic.forget = function forget() {\n        return forgetKey(makeCacheKey.apply(null, arguments));\n    };\n    optimistic.makeCacheKey = makeCacheKey;\n    optimistic.getKey = keyArgs ? function getKey() {\n        return makeCacheKey.apply(null, keyArgs.apply(null, arguments));\n    } : makeCacheKey;\n    return Object.freeze(optimistic);\n}\n//# sourceMappingURL=index.js.map"],"names":["defaultMakeData","forEach","slice","hasOwnProperty","Trie","weakness","makeData","array","node","key","i","len","map","isObjRef","child","value","parentEntrySlot","Slot","arrayFromSet","set","item","maybeUnsubscribe","entryOrDep","unsubscribe","emptySetPool","POOL_TARGET_SIZE","assert","condition","optionalMessage","valueIs","a","b","valueGet","valueCopy","Entry","fn","mightBeDirty","rememberParent","args","reallyRecompute","reportDirty","forgetChildren","eachParent","parent","forgetChild","dep","reportDirtyChild","reportCleanChild","entry","recomputeNewValue","maybeSubscribe","setClean","normalizeResult","oldValueCopy","e","reportClean","callback","parentCount","parents","parentWasClean","childValue","removeDirtyChild","dc","_value","EntryMethods","options","depsByKey","depend","entryMethodName","m","defaultKeyTrie","defaultMakeCacheKey","caches","wrap","originalFunction","max","keyArgs","makeCacheKey","subscribe","cacheOption","StrongCache","cache","optimistic","dirtyKey","peekKey","forgetKey"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5]}