{"version":3,"file":"superstruct-DVoORH0r.js","sources":["../../node_modules/superstruct/dist/index.mjs"],"sourcesContent":["/**\n * A `StructFailure` represents a single specific failure in validation.\n */\n/**\n * `StructError` objects are thrown (or returned) when validation fails.\n *\n * Validation logic is design to exit early for maximum performance. The error\n * represents the first error encountered during validation. For more detail,\n * the `error.failures` property is a generator function that can be run to\n * continue validation and receive all the failures in the data.\n */\nclass StructError extends TypeError {\n    constructor(failure, failures) {\n        let cached;\n        const { message, explanation, ...rest } = failure;\n        const { path } = failure;\n        const msg = path.length === 0 ? message : `At path: ${path.join('.')} -- ${message}`;\n        super(explanation ?? msg);\n        if (explanation != null)\n            this.cause = msg;\n        Object.assign(this, rest);\n        this.name = this.constructor.name;\n        this.failures = () => {\n            return (cached ?? (cached = [failure, ...failures()]));\n        };\n    }\n}\n\n/**\n * Check if a value is an iterator.\n */\nfunction isIterable(x) {\n    return isObject(x) && typeof x[Symbol.iterator] === 'function';\n}\n/**\n * Check if a value is a plain object.\n */\nfunction isObject(x) {\n    return typeof x === 'object' && x != null;\n}\n/**\n * Check if a value is a plain object.\n */\nfunction isPlainObject(x) {\n    if (Object.prototype.toString.call(x) !== '[object Object]') {\n        return false;\n    }\n    const prototype = Object.getPrototypeOf(x);\n    return prototype === null || prototype === Object.prototype;\n}\n/**\n * Return a value as a printable string.\n */\nfunction print(value) {\n    if (typeof value === 'symbol') {\n        return value.toString();\n    }\n    return typeof value === 'string' ? JSON.stringify(value) : `${value}`;\n}\n/**\n * Shifts (removes and returns) the first value from the `input` iterator.\n * Like `Array.prototype.shift()` but for an `Iterator`.\n */\nfunction shiftIterator(input) {\n    const { done, value } = input.next();\n    return done ? undefined : value;\n}\n/**\n * Convert a single validation result to a failure.\n */\nfunction toFailure(result, context, struct, value) {\n    if (result === true) {\n        return;\n    }\n    else if (result === false) {\n        result = {};\n    }\n    else if (typeof result === 'string') {\n        result = { message: result };\n    }\n    const { path, branch } = context;\n    const { type } = struct;\n    const { refinement, message = `Expected a value of type \\`${type}\\`${refinement ? ` with refinement \\`${refinement}\\`` : ''}, but received: \\`${print(value)}\\``, } = result;\n    return {\n        value,\n        type,\n        refinement,\n        key: path[path.length - 1],\n        path,\n        branch,\n        ...result,\n        message,\n    };\n}\n/**\n * Convert a validation result to an iterable of failures.\n */\nfunction* toFailures(result, context, struct, value) {\n    if (!isIterable(result)) {\n        result = [result];\n    }\n    for (const r of result) {\n        const failure = toFailure(r, context, struct, value);\n        if (failure) {\n            yield failure;\n        }\n    }\n}\n/**\n * Check a value against a struct, traversing deeply into nested values, and\n * returning an iterator of failures or success.\n */\nfunction* run(value, struct, options = {}) {\n    const { path = [], branch = [value], coerce = false, mask = false } = options;\n    const ctx = { path, branch };\n    if (coerce) {\n        value = struct.coercer(value, ctx);\n        if (mask &&\n            struct.type !== 'type' &&\n            isObject(struct.schema) &&\n            isObject(value) &&\n            !Array.isArray(value)) {\n            for (const key in value) {\n                if (struct.schema[key] === undefined) {\n                    delete value[key];\n                }\n            }\n        }\n    }\n    let status = 'valid';\n    for (const failure of struct.validator(value, ctx)) {\n        failure.explanation = options.message;\n        status = 'not_valid';\n        yield [failure, undefined];\n    }\n    for (let [k, v, s] of struct.entries(value, ctx)) {\n        const ts = run(v, s, {\n            path: k === undefined ? path : [...path, k],\n            branch: k === undefined ? branch : [...branch, v],\n            coerce,\n            mask,\n            message: options.message,\n        });\n        for (const t of ts) {\n            if (t[0]) {\n                status = t[0].refinement != null ? 'not_refined' : 'not_valid';\n                yield [t[0], undefined];\n            }\n            else if (coerce) {\n                v = t[1];\n                if (k === undefined) {\n                    value = v;\n                }\n                else if (value instanceof Map) {\n                    value.set(k, v);\n                }\n                else if (value instanceof Set) {\n                    value.add(v);\n                }\n                else if (isObject(value)) {\n                    if (v !== undefined || k in value)\n                        value[k] = v;\n                }\n            }\n        }\n    }\n    if (status !== 'not_valid') {\n        for (const failure of struct.refiner(value, ctx)) {\n            failure.explanation = options.message;\n            status = 'not_refined';\n            yield [failure, undefined];\n        }\n    }\n    if (status === 'valid') {\n        yield [undefined, value];\n    }\n}\n\n/**\n * `Struct` objects encapsulate the validation logic for a specific type of\n * values. Once constructed, you use the `assert`, `is` or `validate` helpers to\n * validate unknown input data against the struct.\n */\nclass Struct {\n    constructor(props) {\n        const { type, schema, validator, refiner, coercer = (value) => value, entries = function* () { }, } = props;\n        this.type = type;\n        this.schema = schema;\n        this.entries = entries;\n        this.coercer = coercer;\n        if (validator) {\n            this.validator = (value, context) => {\n                const result = validator(value, context);\n                return toFailures(result, context, this, value);\n            };\n        }\n        else {\n            this.validator = () => [];\n        }\n        if (refiner) {\n            this.refiner = (value, context) => {\n                const result = refiner(value, context);\n                return toFailures(result, context, this, value);\n            };\n        }\n        else {\n            this.refiner = () => [];\n        }\n    }\n    /**\n     * Assert that a value passes the struct's validation, throwing if it doesn't.\n     */\n    assert(value, message) {\n        return assert(value, this, message);\n    }\n    /**\n     * Create a value with the struct's coercion logic, then validate it.\n     */\n    create(value, message) {\n        return create(value, this, message);\n    }\n    /**\n     * Check if a value passes the struct's validation.\n     */\n    is(value) {\n        return is(value, this);\n    }\n    /**\n     * Mask a value, coercing and validating it, but returning only the subset of\n     * properties defined by the struct's schema.\n     */\n    mask(value, message) {\n        return mask(value, this, message);\n    }\n    /**\n     * Validate a value with the struct's validation logic, returning a tuple\n     * representing the result.\n     *\n     * You may optionally pass `true` for the `withCoercion` argument to coerce\n     * the value before attempting to validate it. If you do, the result will\n     * contain the coerced result when successful.\n     */\n    validate(value, options = {}) {\n        return validate(value, this, options);\n    }\n}\n/**\n * Assert that a value passes a struct, throwing if it doesn't.\n */\nfunction assert(value, struct, message) {\n    const result = validate(value, struct, { message });\n    if (result[0]) {\n        throw result[0];\n    }\n}\n/**\n * Create a value with the coercion logic of struct and validate it.\n */\nfunction create(value, struct, message) {\n    const result = validate(value, struct, { coerce: true, message });\n    if (result[0]) {\n        throw result[0];\n    }\n    else {\n        return result[1];\n    }\n}\n/**\n * Mask a value, returning only the subset of properties defined by a struct.\n */\nfunction mask(value, struct, message) {\n    const result = validate(value, struct, { coerce: true, mask: true, message });\n    if (result[0]) {\n        throw result[0];\n    }\n    else {\n        return result[1];\n    }\n}\n/**\n * Check if a value passes a struct.\n */\nfunction is(value, struct) {\n    const result = validate(value, struct);\n    return !result[0];\n}\n/**\n * Validate a value against a struct, returning an error if invalid, or the\n * value (with potential coercion) if valid.\n */\nfunction validate(value, struct, options = {}) {\n    const tuples = run(value, struct, options);\n    const tuple = shiftIterator(tuples);\n    if (tuple[0]) {\n        const error = new StructError(tuple[0], function* () {\n            for (const t of tuples) {\n                if (t[0]) {\n                    yield t[0];\n                }\n            }\n        });\n        return [error, undefined];\n    }\n    else {\n        const v = tuple[1];\n        return [undefined, v];\n    }\n}\n\nfunction assign(...Structs) {\n    const isType = Structs[0].type === 'type';\n    const schemas = Structs.map((s) => s.schema);\n    const schema = Object.assign({}, ...schemas);\n    return isType ? type(schema) : object(schema);\n}\n/**\n * Define a new struct type with a custom validation function.\n */\nfunction define(name, validator) {\n    return new Struct({ type: name, schema: null, validator });\n}\n/**\n * Create a new struct based on an existing struct, but the value is allowed to\n * be `undefined`. `log` will be called if the value is not `undefined`.\n */\nfunction deprecated(struct, log) {\n    return new Struct({\n        ...struct,\n        refiner: (value, ctx) => value === undefined || struct.refiner(value, ctx),\n        validator(value, ctx) {\n            if (value === undefined) {\n                return true;\n            }\n            else {\n                log(value, ctx);\n                return struct.validator(value, ctx);\n            }\n        },\n    });\n}\n/**\n * Create a struct with dynamic validation logic.\n *\n * The callback will receive the value currently being validated, and must\n * return a struct object to validate it with. This can be useful to model\n * validation logic that changes based on its input.\n */\nfunction dynamic(fn) {\n    return new Struct({\n        type: 'dynamic',\n        schema: null,\n        *entries(value, ctx) {\n            const struct = fn(value, ctx);\n            yield* struct.entries(value, ctx);\n        },\n        validator(value, ctx) {\n            const struct = fn(value, ctx);\n            return struct.validator(value, ctx);\n        },\n        coercer(value, ctx) {\n            const struct = fn(value, ctx);\n            return struct.coercer(value, ctx);\n        },\n        refiner(value, ctx) {\n            const struct = fn(value, ctx);\n            return struct.refiner(value, ctx);\n        },\n    });\n}\n/**\n * Create a struct with lazily evaluated validation logic.\n *\n * The first time validation is run with the struct, the callback will be called\n * and must return a struct object to use. This is useful for cases where you\n * want to have self-referential structs for nested data structures to avoid a\n * circular definition problem.\n */\nfunction lazy(fn) {\n    let struct;\n    return new Struct({\n        type: 'lazy',\n        schema: null,\n        *entries(value, ctx) {\n            struct ?? (struct = fn());\n            yield* struct.entries(value, ctx);\n        },\n        validator(value, ctx) {\n            struct ?? (struct = fn());\n            return struct.validator(value, ctx);\n        },\n        coercer(value, ctx) {\n            struct ?? (struct = fn());\n            return struct.coercer(value, ctx);\n        },\n        refiner(value, ctx) {\n            struct ?? (struct = fn());\n            return struct.refiner(value, ctx);\n        },\n    });\n}\n/**\n * Create a new struct based on an existing object struct, but excluding\n * specific properties.\n *\n * Like TypeScript's `Omit` utility.\n */\nfunction omit(struct, keys) {\n    const { schema } = struct;\n    const subschema = { ...schema };\n    for (const key of keys) {\n        delete subschema[key];\n    }\n    switch (struct.type) {\n        case 'type':\n            return type(subschema);\n        default:\n            return object(subschema);\n    }\n}\n/**\n * Create a new struct based on an existing object struct, but with all of its\n * properties allowed to be `undefined`.\n *\n * Like TypeScript's `Partial` utility.\n */\nfunction partial(struct) {\n    const isStruct = struct instanceof Struct;\n    const schema = isStruct ? { ...struct.schema } : { ...struct };\n    for (const key in schema) {\n        schema[key] = optional(schema[key]);\n    }\n    if (isStruct && struct.type === 'type') {\n        return type(schema);\n    }\n    return object(schema);\n}\n/**\n * Create a new struct based on an existing object struct, but only including\n * specific properties.\n *\n * Like TypeScript's `Pick` utility.\n */\nfunction pick(struct, keys) {\n    const { schema } = struct;\n    const subschema = {};\n    for (const key of keys) {\n        subschema[key] = schema[key];\n    }\n    switch (struct.type) {\n        case 'type':\n            return type(subschema);\n        default:\n            return object(subschema);\n    }\n}\n/**\n * Define a new struct type with a custom validation function.\n *\n * @deprecated This function has been renamed to `define`.\n */\nfunction struct(name, validator) {\n    console.warn('superstruct@0.11 - The `struct` helper has been renamed to `define`.');\n    return define(name, validator);\n}\n\n/**\n * Ensure that any value passes validation.\n */\nfunction any() {\n    return define('any', () => true);\n}\nfunction array(Element) {\n    return new Struct({\n        type: 'array',\n        schema: Element,\n        *entries(value) {\n            if (Element && Array.isArray(value)) {\n                for (const [i, v] of value.entries()) {\n                    yield [i, v, Element];\n                }\n            }\n        },\n        coercer(value) {\n            return Array.isArray(value) ? value.slice() : value;\n        },\n        validator(value) {\n            return (Array.isArray(value) ||\n                `Expected an array value, but received: ${print(value)}`);\n        },\n    });\n}\n/**\n * Ensure that a value is a bigint.\n */\nfunction bigint() {\n    return define('bigint', (value) => {\n        return typeof value === 'bigint';\n    });\n}\n/**\n * Ensure that a value is a boolean.\n */\nfunction boolean() {\n    return define('boolean', (value) => {\n        return typeof value === 'boolean';\n    });\n}\n/**\n * Ensure that a value is a valid `Date`.\n *\n * Note: this also ensures that the value is *not* an invalid `Date` object,\n * which can occur when parsing a date fails but still returns a `Date`.\n */\nfunction date() {\n    return define('date', (value) => {\n        return ((value instanceof Date && !isNaN(value.getTime())) ||\n            `Expected a valid \\`Date\\` object, but received: ${print(value)}`);\n    });\n}\nfunction enums(values) {\n    const schema = {};\n    const description = values.map((v) => print(v)).join();\n    for (const key of values) {\n        schema[key] = key;\n    }\n    return new Struct({\n        type: 'enums',\n        schema,\n        validator(value) {\n            return (values.includes(value) ||\n                `Expected one of \\`${description}\\`, but received: ${print(value)}`);\n        },\n    });\n}\n/**\n * Ensure that a value is a function.\n */\nfunction func() {\n    return define('func', (value) => {\n        return (typeof value === 'function' ||\n            `Expected a function, but received: ${print(value)}`);\n    });\n}\n/**\n * Ensure that a value is an instance of a specific class.\n */\nfunction instance(Class) {\n    return define('instance', (value) => {\n        return (value instanceof Class ||\n            `Expected a \\`${Class.name}\\` instance, but received: ${print(value)}`);\n    });\n}\n/**\n * Ensure that a value is an integer.\n */\nfunction integer() {\n    return define('integer', (value) => {\n        return ((typeof value === 'number' && !isNaN(value) && Number.isInteger(value)) ||\n            `Expected an integer, but received: ${print(value)}`);\n    });\n}\n/**\n * Ensure that a value matches all of a set of types.\n */\nfunction intersection(Structs) {\n    return new Struct({\n        type: 'intersection',\n        schema: null,\n        *entries(value, ctx) {\n            for (const S of Structs) {\n                yield* S.entries(value, ctx);\n            }\n        },\n        *validator(value, ctx) {\n            for (const S of Structs) {\n                yield* S.validator(value, ctx);\n            }\n        },\n        *refiner(value, ctx) {\n            for (const S of Structs) {\n                yield* S.refiner(value, ctx);\n            }\n        },\n    });\n}\nfunction literal(constant) {\n    const description = print(constant);\n    const t = typeof constant;\n    return new Struct({\n        type: 'literal',\n        schema: t === 'string' || t === 'number' || t === 'boolean' ? constant : null,\n        validator(value) {\n            return (value === constant ||\n                `Expected the literal \\`${description}\\`, but received: ${print(value)}`);\n        },\n    });\n}\nfunction map(Key, Value) {\n    return new Struct({\n        type: 'map',\n        schema: null,\n        *entries(value) {\n            if (Key && Value && value instanceof Map) {\n                for (const [k, v] of value.entries()) {\n                    yield [k, k, Key];\n                    yield [k, v, Value];\n                }\n            }\n        },\n        coercer(value) {\n            return value instanceof Map ? new Map(value) : value;\n        },\n        validator(value) {\n            return (value instanceof Map ||\n                `Expected a \\`Map\\` object, but received: ${print(value)}`);\n        },\n    });\n}\n/**\n * Ensure that no value ever passes validation.\n */\nfunction never() {\n    return define('never', () => false);\n}\n/**\n * Augment an existing struct to allow `null` values.\n */\nfunction nullable(struct) {\n    return new Struct({\n        ...struct,\n        validator: (value, ctx) => value === null || struct.validator(value, ctx),\n        refiner: (value, ctx) => value === null || struct.refiner(value, ctx),\n    });\n}\n/**\n * Ensure that a value is a number.\n */\nfunction number() {\n    return define('number', (value) => {\n        return ((typeof value === 'number' && !isNaN(value)) ||\n            `Expected a number, but received: ${print(value)}`);\n    });\n}\nfunction object(schema) {\n    const knowns = schema ? Object.keys(schema) : [];\n    const Never = never();\n    return new Struct({\n        type: 'object',\n        schema: schema ? schema : null,\n        *entries(value) {\n            if (schema && isObject(value)) {\n                const unknowns = new Set(Object.keys(value));\n                for (const key of knowns) {\n                    unknowns.delete(key);\n                    yield [key, value[key], schema[key]];\n                }\n                for (const key of unknowns) {\n                    yield [key, value[key], Never];\n                }\n            }\n        },\n        validator(value) {\n            return (isObject(value) || `Expected an object, but received: ${print(value)}`);\n        },\n        coercer(value) {\n            return isObject(value) ? { ...value } : value;\n        },\n    });\n}\n/**\n * Augment a struct to allow `undefined` values.\n */\nfunction optional(struct) {\n    return new Struct({\n        ...struct,\n        validator: (value, ctx) => value === undefined || struct.validator(value, ctx),\n        refiner: (value, ctx) => value === undefined || struct.refiner(value, ctx),\n    });\n}\n/**\n * Ensure that a value is an object with keys and values of specific types, but\n * without ensuring any specific shape of properties.\n *\n * Like TypeScript's `Record` utility.\n */\nfunction record(Key, Value) {\n    return new Struct({\n        type: 'record',\n        schema: null,\n        *entries(value) {\n            if (isObject(value)) {\n                for (const k in value) {\n                    const v = value[k];\n                    yield [k, k, Key];\n                    yield [k, v, Value];\n                }\n            }\n        },\n        validator(value) {\n            return (isObject(value) || `Expected an object, but received: ${print(value)}`);\n        },\n    });\n}\n/**\n * Ensure that a value is a `RegExp`.\n *\n * Note: this does not test the value against the regular expression! For that\n * you need to use the `pattern()` refinement.\n */\nfunction regexp() {\n    return define('regexp', (value) => {\n        return value instanceof RegExp;\n    });\n}\nfunction set(Element) {\n    return new Struct({\n        type: 'set',\n        schema: null,\n        *entries(value) {\n            if (Element && value instanceof Set) {\n                for (const v of value) {\n                    yield [v, v, Element];\n                }\n            }\n        },\n        coercer(value) {\n            return value instanceof Set ? new Set(value) : value;\n        },\n        validator(value) {\n            return (value instanceof Set ||\n                `Expected a \\`Set\\` object, but received: ${print(value)}`);\n        },\n    });\n}\n/**\n * Ensure that a value is a string.\n */\nfunction string() {\n    return define('string', (value) => {\n        return (typeof value === 'string' ||\n            `Expected a string, but received: ${print(value)}`);\n    });\n}\n/**\n * Ensure that a value is a tuple of a specific length, and that each of its\n * elements is of a specific type.\n */\nfunction tuple(Structs) {\n    const Never = never();\n    return new Struct({\n        type: 'tuple',\n        schema: null,\n        *entries(value) {\n            if (Array.isArray(value)) {\n                const length = Math.max(Structs.length, value.length);\n                for (let i = 0; i < length; i++) {\n                    yield [i, value[i], Structs[i] || Never];\n                }\n            }\n        },\n        validator(value) {\n            return (Array.isArray(value) ||\n                `Expected an array, but received: ${print(value)}`);\n        },\n    });\n}\n/**\n * Ensure that a value has a set of known properties of specific types.\n *\n * Note: Unrecognized properties are allowed and untouched. This is similar to\n * how TypeScript's structural typing works.\n */\nfunction type(schema) {\n    const keys = Object.keys(schema);\n    return new Struct({\n        type: 'type',\n        schema,\n        *entries(value) {\n            if (isObject(value)) {\n                for (const k of keys) {\n                    yield [k, value[k], schema[k]];\n                }\n            }\n        },\n        validator(value) {\n            return (isObject(value) || `Expected an object, but received: ${print(value)}`);\n        },\n        coercer(value) {\n            return isObject(value) ? { ...value } : value;\n        },\n    });\n}\n/**\n * Ensure that a value matches one of a set of types.\n */\nfunction union(Structs) {\n    const description = Structs.map((s) => s.type).join(' | ');\n    return new Struct({\n        type: 'union',\n        schema: null,\n        coercer(value) {\n            for (const S of Structs) {\n                const [error, coerced] = S.validate(value, { coerce: true });\n                if (!error) {\n                    return coerced;\n                }\n            }\n            return value;\n        },\n        validator(value, ctx) {\n            const failures = [];\n            for (const S of Structs) {\n                const [...tuples] = run(value, S, ctx);\n                const [first] = tuples;\n                if (!first[0]) {\n                    return [];\n                }\n                else {\n                    for (const [failure] of tuples) {\n                        if (failure) {\n                            failures.push(failure);\n                        }\n                    }\n                }\n            }\n            return [\n                `Expected the value to satisfy a union of \\`${description}\\`, but received: ${print(value)}`,\n                ...failures,\n            ];\n        },\n    });\n}\n/**\n * Ensure that any value passes validation, without widening its type to `any`.\n */\nfunction unknown() {\n    return define('unknown', () => true);\n}\n\n/**\n * Augment a `Struct` to add an additional coercion step to its input.\n *\n * This allows you to transform input data before validating it, to increase the\n * likelihood that it passes validationâ€”for example for default values, parsing\n * different formats, etc.\n *\n * Note: You must use `create(value, Struct)` on the value to have the coercion\n * take effect! Using simply `assert()` or `is()` will not use coercion.\n */\nfunction coerce(struct, condition, coercer) {\n    return new Struct({\n        ...struct,\n        coercer: (value, ctx) => {\n            return is(value, condition)\n                ? struct.coercer(coercer(value, ctx), ctx)\n                : struct.coercer(value, ctx);\n        },\n    });\n}\n/**\n * Augment a struct to replace `undefined` values with a default.\n *\n * Note: You must use `create(value, Struct)` on the value to have the coercion\n * take effect! Using simply `assert()` or `is()` will not use coercion.\n */\nfunction defaulted(struct, fallback, options = {}) {\n    return coerce(struct, unknown(), (x) => {\n        const f = typeof fallback === 'function' ? fallback() : fallback;\n        if (x === undefined) {\n            return f;\n        }\n        if (!options.strict && isPlainObject(x) && isPlainObject(f)) {\n            const ret = { ...x };\n            let changed = false;\n            for (const key in f) {\n                if (ret[key] === undefined) {\n                    ret[key] = f[key];\n                    changed = true;\n                }\n            }\n            if (changed) {\n                return ret;\n            }\n        }\n        return x;\n    });\n}\n/**\n * Augment a struct to trim string inputs.\n *\n * Note: You must use `create(value, Struct)` on the value to have the coercion\n * take effect! Using simply `assert()` or `is()` will not use coercion.\n */\nfunction trimmed(struct) {\n    return coerce(struct, string(), (x) => x.trim());\n}\n\n/**\n * Ensure that a string, array, map, or set is empty.\n */\nfunction empty(struct) {\n    return refine(struct, 'empty', (value) => {\n        const size = getSize(value);\n        return (size === 0 ||\n            `Expected an empty ${struct.type} but received one with a size of \\`${size}\\``);\n    });\n}\nfunction getSize(value) {\n    if (value instanceof Map || value instanceof Set) {\n        return value.size;\n    }\n    else {\n        return value.length;\n    }\n}\n/**\n * Ensure that a number or date is below a threshold.\n */\nfunction max(struct, threshold, options = {}) {\n    const { exclusive } = options;\n    return refine(struct, 'max', (value) => {\n        return exclusive\n            ? value < threshold\n            : value <= threshold ||\n                `Expected a ${struct.type} less than ${exclusive ? '' : 'or equal to '}${threshold} but received \\`${value}\\``;\n    });\n}\n/**\n * Ensure that a number or date is above a threshold.\n */\nfunction min(struct, threshold, options = {}) {\n    const { exclusive } = options;\n    return refine(struct, 'min', (value) => {\n        return exclusive\n            ? value > threshold\n            : value >= threshold ||\n                `Expected a ${struct.type} greater than ${exclusive ? '' : 'or equal to '}${threshold} but received \\`${value}\\``;\n    });\n}\n/**\n * Ensure that a string, array, map or set is not empty.\n */\nfunction nonempty(struct) {\n    return refine(struct, 'nonempty', (value) => {\n        const size = getSize(value);\n        return (size > 0 || `Expected a nonempty ${struct.type} but received an empty one`);\n    });\n}\n/**\n * Ensure that a string matches a regular expression.\n */\nfunction pattern(struct, regexp) {\n    return refine(struct, 'pattern', (value) => {\n        return (regexp.test(value) ||\n            `Expected a ${struct.type} matching \\`/${regexp.source}/\\` but received \"${value}\"`);\n    });\n}\n/**\n * Ensure that a string, array, number, date, map, or set has a size (or length, or time) between `min` and `max`.\n */\nfunction size(struct, min, max = min) {\n    const expected = `Expected a ${struct.type}`;\n    const of = min === max ? `of \\`${min}\\`` : `between \\`${min}\\` and \\`${max}\\``;\n    return refine(struct, 'size', (value) => {\n        if (typeof value === 'number' || value instanceof Date) {\n            return ((min <= value && value <= max) ||\n                `${expected} ${of} but received \\`${value}\\``);\n        }\n        else if (value instanceof Map || value instanceof Set) {\n            const { size } = value;\n            return ((min <= size && size <= max) ||\n                `${expected} with a size ${of} but received one with a size of \\`${size}\\``);\n        }\n        else {\n            const { length } = value;\n            return ((min <= length && length <= max) ||\n                `${expected} with a length ${of} but received one with a length of \\`${length}\\``);\n        }\n    });\n}\n/**\n * Augment a `Struct` to add an additional refinement to the validation.\n *\n * The refiner function is guaranteed to receive a value of the struct's type,\n * because the struct's existing validation will already have passed. This\n * allows you to layer additional validation on top of existing structs.\n */\nfunction refine(struct, name, refiner) {\n    return new Struct({\n        ...struct,\n        *refiner(value, ctx) {\n            yield* struct.refiner(value, ctx);\n            const result = refiner(value, ctx);\n            const failures = toFailures(result, ctx, struct, value);\n            for (const failure of failures) {\n                yield { ...failure, refinement: name };\n            }\n        },\n    });\n}\n\nexport { Struct, StructError, any, array, assert, assign, bigint, boolean, coerce, create, date, defaulted, define, deprecated, dynamic, empty, enums, func, instance, integer, intersection, is, lazy, literal, map, mask, max, min, never, nonempty, nullable, number, object, omit, optional, partial, pattern, pick, record, refine, regexp, set, size, string, struct, trimmed, tuple, type, union, unknown, validate };\n//# sourceMappingURL=index.mjs.map\n"],"names":["StructError","failure","failures","cached","message","explanation","rest","path","msg","isIterable","x","isObject","isPlainObject","prototype","print","value","shiftIterator","input","done","toFailure","result","context","struct","branch","type","refinement","toFailures","r","run","options","coerce","mask","ctx","key","status","k","v","s","ts","t","Struct","props","schema","validator","refiner","coercer","entries","assert","create","is","validate","tuples","tuple","assign","Structs","isType","schemas","object","define","name","deprecated","log","dynamic","fn","lazy","omit","keys","subschema","partial","isStruct","optional","pick","any","array","Element","i","bigint","boolean","date","enums","values","description","func","instance","Class","integer","intersection","S","literal","constant","map","Key","Value","never","nullable","number","knowns","Never","unknowns","record","regexp","set","string","length","union","error","coerced","first","unknown","condition","defaulted","fallback","f","ret","changed","trimmed","empty","refine","size","getSize","max","threshold","exclusive","min","nonempty","pattern","expected","of"],"mappings":"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","x_google_ignoreList":[0]}