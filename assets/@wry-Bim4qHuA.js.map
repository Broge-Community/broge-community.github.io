{"version":3,"file":"@wry-Bim4qHuA.js","sources":["../../node_modules/@wry/trie/lib/index.js","../../node_modules/@wry/caches/lib/strong.js","../../node_modules/@wry/caches/lib/weak.js","../../node_modules/@wry/context/lib/slot.js","../../node_modules/@wry/equality/lib/index.js"],"sourcesContent":["// A [trie](https://en.wikipedia.org/wiki/Trie) data structure that holds\n// object keys weakly, yet can also hold non-object keys, unlike the\n// native `WeakMap`.\n// If no makeData function is supplied, the looked-up data will be an empty,\n// null-prototype Object.\nconst defaultMakeData = () => Object.create(null);\n// Useful for processing arguments objects as well as arrays.\nconst { forEach, slice } = Array.prototype;\nconst { hasOwnProperty } = Object.prototype;\nexport class Trie {\n    constructor(weakness = true, makeData = defaultMakeData) {\n        this.weakness = weakness;\n        this.makeData = makeData;\n    }\n    lookup() {\n        return this.lookupArray(arguments);\n    }\n    lookupArray(array) {\n        let node = this;\n        forEach.call(array, key => node = node.getChildTrie(key));\n        return hasOwnProperty.call(node, \"data\")\n            ? node.data\n            : node.data = this.makeData(slice.call(array));\n    }\n    peek() {\n        return this.peekArray(arguments);\n    }\n    peekArray(array) {\n        let node = this;\n        for (let i = 0, len = array.length; node && i < len; ++i) {\n            const map = node.mapFor(array[i], false);\n            node = map && map.get(array[i]);\n        }\n        return node && node.data;\n    }\n    remove() {\n        return this.removeArray(arguments);\n    }\n    removeArray(array) {\n        let data;\n        if (array.length) {\n            const head = array[0];\n            const map = this.mapFor(head, false);\n            const child = map && map.get(head);\n            if (child) {\n                data = child.removeArray(slice.call(array, 1));\n                if (!child.data && !child.weak && !(child.strong && child.strong.size)) {\n                    map.delete(head);\n                }\n            }\n        }\n        else {\n            data = this.data;\n            delete this.data;\n        }\n        return data;\n    }\n    getChildTrie(key) {\n        const map = this.mapFor(key, true);\n        let child = map.get(key);\n        if (!child)\n            map.set(key, child = new Trie(this.weakness, this.makeData));\n        return child;\n    }\n    mapFor(key, create) {\n        return this.weakness && isObjRef(key)\n            ? this.weak || (create ? this.weak = new WeakMap : void 0)\n            : this.strong || (create ? this.strong = new Map : void 0);\n    }\n}\nfunction isObjRef(value) {\n    switch (typeof value) {\n        case \"object\":\n            if (value === null)\n                break;\n        // Fall through to return true...\n        case \"function\":\n            return true;\n    }\n    return false;\n}\n//# sourceMappingURL=index.js.map","function defaultDispose() { }\nexport class StrongCache {\n    constructor(max = Infinity, dispose = defaultDispose) {\n        this.max = max;\n        this.dispose = dispose;\n        this.map = new Map();\n        this.newest = null;\n        this.oldest = null;\n    }\n    has(key) {\n        return this.map.has(key);\n    }\n    get(key) {\n        const node = this.getNode(key);\n        return node && node.value;\n    }\n    get size() {\n        return this.map.size;\n    }\n    getNode(key) {\n        const node = this.map.get(key);\n        if (node && node !== this.newest) {\n            const { older, newer } = node;\n            if (newer) {\n                newer.older = older;\n            }\n            if (older) {\n                older.newer = newer;\n            }\n            node.older = this.newest;\n            node.older.newer = node;\n            node.newer = null;\n            this.newest = node;\n            if (node === this.oldest) {\n                this.oldest = newer;\n            }\n        }\n        return node;\n    }\n    set(key, value) {\n        let node = this.getNode(key);\n        if (node) {\n            return node.value = value;\n        }\n        node = {\n            key,\n            value,\n            newer: null,\n            older: this.newest\n        };\n        if (this.newest) {\n            this.newest.newer = node;\n        }\n        this.newest = node;\n        this.oldest = this.oldest || node;\n        this.map.set(key, node);\n        return node.value;\n    }\n    clean() {\n        while (this.oldest && this.map.size > this.max) {\n            this.delete(this.oldest.key);\n        }\n    }\n    delete(key) {\n        const node = this.map.get(key);\n        if (node) {\n            if (node === this.newest) {\n                this.newest = node.older;\n            }\n            if (node === this.oldest) {\n                this.oldest = node.newer;\n            }\n            if (node.newer) {\n                node.newer.older = node.older;\n            }\n            if (node.older) {\n                node.older.newer = node.newer;\n            }\n            this.map.delete(key);\n            this.dispose(node.value, key);\n            return true;\n        }\n        return false;\n    }\n}\n//# sourceMappingURL=strong.js.map","function noop() { }\nconst defaultDispose = noop;\nconst _WeakRef = typeof WeakRef !== \"undefined\"\n    ? WeakRef\n    : function (value) {\n        return { deref: () => value };\n    };\nconst _WeakMap = typeof WeakMap !== \"undefined\" ? WeakMap : Map;\nconst _FinalizationRegistry = typeof FinalizationRegistry !== \"undefined\"\n    ? FinalizationRegistry\n    : function () {\n        return {\n            register: noop,\n            unregister: noop,\n        };\n    };\nconst finalizationBatchSize = 10024;\nexport class WeakCache {\n    constructor(max = Infinity, dispose = defaultDispose) {\n        this.max = max;\n        this.dispose = dispose;\n        this.map = new _WeakMap();\n        this.newest = null;\n        this.oldest = null;\n        this.unfinalizedNodes = new Set();\n        this.finalizationScheduled = false;\n        this.size = 0;\n        this.finalize = () => {\n            const iterator = this.unfinalizedNodes.values();\n            for (let i = 0; i < finalizationBatchSize; i++) {\n                const node = iterator.next().value;\n                if (!node)\n                    break;\n                this.unfinalizedNodes.delete(node);\n                const key = node.key;\n                delete node.key;\n                node.keyRef = new _WeakRef(key);\n                this.registry.register(key, node, node);\n            }\n            if (this.unfinalizedNodes.size > 0) {\n                queueMicrotask(this.finalize);\n            }\n            else {\n                this.finalizationScheduled = false;\n            }\n        };\n        this.registry = new _FinalizationRegistry(this.deleteNode.bind(this));\n    }\n    has(key) {\n        return this.map.has(key);\n    }\n    get(key) {\n        const node = this.getNode(key);\n        return node && node.value;\n    }\n    getNode(key) {\n        const node = this.map.get(key);\n        if (node && node !== this.newest) {\n            const { older, newer } = node;\n            if (newer) {\n                newer.older = older;\n            }\n            if (older) {\n                older.newer = newer;\n            }\n            node.older = this.newest;\n            node.older.newer = node;\n            node.newer = null;\n            this.newest = node;\n            if (node === this.oldest) {\n                this.oldest = newer;\n            }\n        }\n        return node;\n    }\n    set(key, value) {\n        let node = this.getNode(key);\n        if (node) {\n            return (node.value = value);\n        }\n        node = {\n            key,\n            value,\n            newer: null,\n            older: this.newest,\n        };\n        if (this.newest) {\n            this.newest.newer = node;\n        }\n        this.newest = node;\n        this.oldest = this.oldest || node;\n        this.scheduleFinalization(node);\n        this.map.set(key, node);\n        this.size++;\n        return node.value;\n    }\n    clean() {\n        while (this.oldest && this.size > this.max) {\n            this.deleteNode(this.oldest);\n        }\n    }\n    deleteNode(node) {\n        if (node === this.newest) {\n            this.newest = node.older;\n        }\n        if (node === this.oldest) {\n            this.oldest = node.newer;\n        }\n        if (node.newer) {\n            node.newer.older = node.older;\n        }\n        if (node.older) {\n            node.older.newer = node.newer;\n        }\n        this.size--;\n        const key = node.key || (node.keyRef && node.keyRef.deref());\n        this.dispose(node.value, key);\n        if (!node.keyRef) {\n            this.unfinalizedNodes.delete(node);\n        }\n        else {\n            this.registry.unregister(node);\n        }\n        if (key)\n            this.map.delete(key);\n    }\n    delete(key) {\n        const node = this.map.get(key);\n        if (node) {\n            this.deleteNode(node);\n            return true;\n        }\n        return false;\n    }\n    scheduleFinalization(node) {\n        this.unfinalizedNodes.add(node);\n        if (!this.finalizationScheduled) {\n            this.finalizationScheduled = true;\n            queueMicrotask(this.finalize);\n        }\n    }\n}\n//# sourceMappingURL=weak.js.map","// This currentContext variable will only be used if the makeSlotClass\n// function is called, which happens only if this is the first copy of the\n// @wry/context package to be imported.\nlet currentContext = null;\n// This unique internal object is used to denote the absence of a value\n// for a given Slot, and is never exposed to outside code.\nconst MISSING_VALUE = {};\nlet idCounter = 1;\n// Although we can't do anything about the cost of duplicated code from\n// accidentally bundling multiple copies of the @wry/context package, we can\n// avoid creating the Slot class more than once using makeSlotClass.\nconst makeSlotClass = () => class Slot {\n    constructor() {\n        // If you have a Slot object, you can find out its slot.id, but you cannot\n        // guess the slot.id of a Slot you don't have access to, thanks to the\n        // randomized suffix.\n        this.id = [\n            \"slot\",\n            idCounter++,\n            Date.now(),\n            Math.random().toString(36).slice(2),\n        ].join(\":\");\n    }\n    hasValue() {\n        for (let context = currentContext; context; context = context.parent) {\n            // We use the Slot object iself as a key to its value, which means the\n            // value cannot be obtained without a reference to the Slot object.\n            if (this.id in context.slots) {\n                const value = context.slots[this.id];\n                if (value === MISSING_VALUE)\n                    break;\n                if (context !== currentContext) {\n                    // Cache the value in currentContext.slots so the next lookup will\n                    // be faster. This caching is safe because the tree of contexts and\n                    // the values of the slots are logically immutable.\n                    currentContext.slots[this.id] = value;\n                }\n                return true;\n            }\n        }\n        if (currentContext) {\n            // If a value was not found for this Slot, it's never going to be found\n            // no matter how many times we look it up, so we might as well cache\n            // the absence of the value, too.\n            currentContext.slots[this.id] = MISSING_VALUE;\n        }\n        return false;\n    }\n    getValue() {\n        if (this.hasValue()) {\n            return currentContext.slots[this.id];\n        }\n    }\n    withValue(value, callback, \n    // Given the prevalence of arrow functions, specifying arguments is likely\n    // to be much more common than specifying `this`, hence this ordering:\n    args, thisArg) {\n        const slots = {\n            __proto__: null,\n            [this.id]: value,\n        };\n        const parent = currentContext;\n        currentContext = { parent, slots };\n        try {\n            // Function.prototype.apply allows the arguments array argument to be\n            // omitted or undefined, so args! is fine here.\n            return callback.apply(thisArg, args);\n        }\n        finally {\n            currentContext = parent;\n        }\n    }\n    // Capture the current context and wrap a callback function so that it\n    // reestablishes the captured context when called.\n    static bind(callback) {\n        const context = currentContext;\n        return function () {\n            const saved = currentContext;\n            try {\n                currentContext = context;\n                return callback.apply(this, arguments);\n            }\n            finally {\n                currentContext = saved;\n            }\n        };\n    }\n    // Immediately run a callback function without any captured context.\n    static noContext(callback, \n    // Given the prevalence of arrow functions, specifying arguments is likely\n    // to be much more common than specifying `this`, hence this ordering:\n    args, thisArg) {\n        if (currentContext) {\n            const saved = currentContext;\n            try {\n                currentContext = null;\n                // Function.prototype.apply allows the arguments array argument to be\n                // omitted or undefined, so args! is fine here.\n                return callback.apply(thisArg, args);\n            }\n            finally {\n                currentContext = saved;\n            }\n        }\n        else {\n            return callback.apply(thisArg, args);\n        }\n    }\n};\nfunction maybe(fn) {\n    try {\n        return fn();\n    }\n    catch (ignored) { }\n}\n// We store a single global implementation of the Slot class as a permanent\n// non-enumerable property of the globalThis object. This obfuscation does\n// nothing to prevent access to the Slot class, but at least it ensures the\n// implementation (i.e. currentContext) cannot be tampered with, and all copies\n// of the @wry/context package (hopefully just one) will share the same Slot\n// implementation. Since the first copy of the @wry/context package to be\n// imported wins, this technique imposes a steep cost for any future breaking\n// changes to the Slot class.\nconst globalKey = \"@wry/context:Slot\";\nconst host = \n// Prefer globalThis when available.\n// https://github.com/benjamn/wryware/issues/347\nmaybe(() => globalThis) ||\n    // Fall back to global, which works in Node.js and may be converted by some\n    // bundlers to the appropriate identifier (window, self, ...) depending on the\n    // bundling target. https://github.com/endojs/endo/issues/576#issuecomment-1178515224\n    maybe(() => global) ||\n    // Otherwise, use a dummy host that's local to this module. We used to fall\n    // back to using the Array constructor as a namespace, but that was flagged in\n    // https://github.com/benjamn/wryware/issues/347, and can be avoided.\n    Object.create(null);\n// Whichever globalHost we're using, make TypeScript happy about the additional\n// globalKey property.\nconst globalHost = host;\nexport const Slot = globalHost[globalKey] ||\n    // Earlier versions of this package stored the globalKey property on the Array\n    // constructor, so we check there as well, to prevent Slot class duplication.\n    Array[globalKey] ||\n    (function (Slot) {\n        try {\n            Object.defineProperty(globalHost, globalKey, {\n                value: Slot,\n                enumerable: false,\n                writable: false,\n                // When it was possible for globalHost to be the Array constructor (a\n                // legacy Slot dedup strategy), it was important for the property to be\n                // configurable:true so it could be deleted. That does not seem to be as\n                // important when globalHost is the global object, but I don't want to\n                // cause similar problems again, and configurable:true seems safest.\n                // https://github.com/endojs/endo/issues/576#issuecomment-1178274008\n                configurable: true\n            });\n        }\n        finally {\n            return Slot;\n        }\n    })(makeSlotClass());\n//# sourceMappingURL=slot.js.map","const { toString, hasOwnProperty } = Object.prototype;\nconst fnToStr = Function.prototype.toString;\nconst previousComparisons = new Map();\n/**\n * Performs a deep equality check on two JavaScript values, tolerating cycles.\n */\nexport function equal(a, b) {\n    try {\n        return check(a, b);\n    }\n    finally {\n        previousComparisons.clear();\n    }\n}\n// Allow default imports as well.\nexport default equal;\nfunction check(a, b) {\n    // If the two values are strictly equal, our job is easy.\n    if (a === b) {\n        return true;\n    }\n    // Object.prototype.toString returns a representation of the runtime type of\n    // the given value that is considerably more precise than typeof.\n    const aTag = toString.call(a);\n    const bTag = toString.call(b);\n    // If the runtime types of a and b are different, they could maybe be equal\n    // under some interpretation of equality, but for simplicity and performance\n    // we just return false instead.\n    if (aTag !== bTag) {\n        return false;\n    }\n    switch (aTag) {\n        case '[object Array]':\n            // Arrays are a lot like other objects, but we can cheaply compare their\n            // lengths as a short-cut before comparing their elements.\n            if (a.length !== b.length)\n                return false;\n        // Fall through to object case...\n        case '[object Object]': {\n            if (previouslyCompared(a, b))\n                return true;\n            const aKeys = definedKeys(a);\n            const bKeys = definedKeys(b);\n            // If `a` and `b` have a different number of enumerable keys, they\n            // must be different.\n            const keyCount = aKeys.length;\n            if (keyCount !== bKeys.length)\n                return false;\n            // Now make sure they have the same keys.\n            for (let k = 0; k < keyCount; ++k) {\n                if (!hasOwnProperty.call(b, aKeys[k])) {\n                    return false;\n                }\n            }\n            // Finally, check deep equality of all child properties.\n            for (let k = 0; k < keyCount; ++k) {\n                const key = aKeys[k];\n                if (!check(a[key], b[key])) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        case '[object Error]':\n            return a.name === b.name && a.message === b.message;\n        case '[object Number]':\n            // Handle NaN, which is !== itself.\n            if (a !== a)\n                return b !== b;\n        // Fall through to shared +a === +b case...\n        case '[object Boolean]':\n        case '[object Date]':\n            return +a === +b;\n        case '[object RegExp]':\n        case '[object String]':\n            return a == `${b}`;\n        case '[object Map]':\n        case '[object Set]': {\n            if (a.size !== b.size)\n                return false;\n            if (previouslyCompared(a, b))\n                return true;\n            const aIterator = a.entries();\n            const isMap = aTag === '[object Map]';\n            while (true) {\n                const info = aIterator.next();\n                if (info.done)\n                    break;\n                // If a instanceof Set, aValue === aKey.\n                const [aKey, aValue] = info.value;\n                // So this works the same way for both Set and Map.\n                if (!b.has(aKey)) {\n                    return false;\n                }\n                // However, we care about deep equality of values only when dealing\n                // with Map structures.\n                if (isMap && !check(aValue, b.get(aKey))) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        case '[object Uint16Array]':\n        case '[object Uint8Array]': // Buffer, in Node.js.\n        case '[object Uint32Array]':\n        case '[object Int32Array]':\n        case '[object Int8Array]':\n        case '[object Int16Array]':\n        case '[object ArrayBuffer]':\n            // DataView doesn't need these conversions, but the equality check is\n            // otherwise the same.\n            a = new Uint8Array(a);\n            b = new Uint8Array(b);\n        // Fall through...\n        case '[object DataView]': {\n            let len = a.byteLength;\n            if (len === b.byteLength) {\n                while (len-- && a[len] === b[len]) {\n                    // Keep looping as long as the bytes are equal.\n                }\n            }\n            return len === -1;\n        }\n        case '[object AsyncFunction]':\n        case '[object GeneratorFunction]':\n        case '[object AsyncGeneratorFunction]':\n        case '[object Function]': {\n            const aCode = fnToStr.call(a);\n            if (aCode !== fnToStr.call(b)) {\n                return false;\n            }\n            // We consider non-native functions equal if they have the same code\n            // (native functions require === because their code is censored).\n            // Note that this behavior is not entirely sound, since !== function\n            // objects with the same code can behave differently depending on\n            // their closure scope. However, any function can behave differently\n            // depending on the values of its input arguments (including this)\n            // and its calling context (including its closure scope), even\n            // though the function object is === to itself; and it is entirely\n            // possible for functions that are not === to behave exactly the\n            // same under all conceivable circumstances. Because none of these\n            // factors are statically decidable in JavaScript, JS function\n            // equality is not well-defined. This ambiguity allows us to\n            // consider the best possible heuristic among various imperfect\n            // options, and equating non-native functions that have the same\n            // code has enormous practical benefits, such as when comparing\n            // functions that are repeatedly passed as fresh function\n            // expressions within objects that are otherwise deeply equal. Since\n            // any function created from the same syntactic expression (in the\n            // same code location) will always stringify to the same code\n            // according to fnToStr.call, we can reasonably expect these\n            // repeatedly passed function expressions to have the same code, and\n            // thus behave \"the same\" (with all the caveats mentioned above),\n            // even though the runtime function objects are !== to one another.\n            return !endsWith(aCode, nativeCodeSuffix);\n        }\n    }\n    // Otherwise the values are not equal.\n    return false;\n}\nfunction definedKeys(obj) {\n    // Remember that the second argument to Array.prototype.filter will be\n    // used as `this` within the callback function.\n    return Object.keys(obj).filter(isDefinedKey, obj);\n}\nfunction isDefinedKey(key) {\n    return this[key] !== void 0;\n}\nconst nativeCodeSuffix = \"{ [native code] }\";\nfunction endsWith(full, suffix) {\n    const fromIndex = full.length - suffix.length;\n    return fromIndex >= 0 &&\n        full.indexOf(suffix, fromIndex) === fromIndex;\n}\nfunction previouslyCompared(a, b) {\n    // Though cyclic references can make an object graph appear infinite from the\n    // perspective of a depth-first traversal, the graph still contains a finite\n    // number of distinct object references. We use the previousComparisons cache\n    // to avoid comparing the same pair of object references more than once, which\n    // guarantees termination (even if we end up comparing every object in one\n    // graph to every object in the other graph, which is extremely unlikely),\n    // while still allowing weird isomorphic structures (like rings with different\n    // lengths) a chance to pass the equality test.\n    let bSet = previousComparisons.get(a);\n    if (bSet) {\n        // Return true here because we can be sure false will be returned somewhere\n        // else if the objects are not equivalent.\n        if (bSet.has(b))\n            return true;\n    }\n    else {\n        previousComparisons.set(a, bSet = new Set);\n    }\n    bSet.add(b);\n    return false;\n}\n//# sourceMappingURL=index.js.map"],"names":["defaultMakeData","forEach","slice","hasOwnProperty","Trie","weakness","makeData","array","node","key","i","len","map","data","head","child","create","isObjRef","value","defaultDispose","StrongCache","max","dispose","older","newer","noop","_WeakRef","_WeakMap","_FinalizationRegistry","finalizationBatchSize","WeakCache","iterator","currentContext","MISSING_VALUE","idCounter","makeSlotClass","context","callback","args","thisArg","slots","parent","saved","maybe","fn","globalKey","host","globalHost","Slot","toString","fnToStr","previousComparisons","equal","a","b","check","aTag","bTag","previouslyCompared","aKeys","definedKeys","bKeys","keyCount","k","aIterator","isMap","info","aKey","aValue","aCode","endsWith","nativeCodeSuffix","obj","isDefinedKey","full","suffix","fromIndex","bSet"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4]}